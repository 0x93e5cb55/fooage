---
layout: post
title: 'Go上下文控制线程'
date: 2020-08-02 11:20:23 +0800
categories: Golang
---

以上记录有一种是用退出通知机制来协调通道的打开关闭的方法使用`select`但是对于多层线程的调用，这一方法显得不优雅，力不从心，所以出现了`context`包来协调线程之间的开始关闭，起到线程之间通知的作用。主要利用的底层还是一个通道用来存储通知信息在线程之间，**通常应用在多层线程的情况**。

## 上下文的意义

对于`Go`语言来说，各个线程是平行的关系，每一个线程都是同样等级不存在父子关系，所以不同功能层的线程结束的时候无法结束相关的其他线程，这时候需要生成一个`context`来作为线程函数的一个参数传入就可以通过这个参数来控制线程。

## 管理线程

对于这个包的设计目的第一个就是包装退出通知机制，通知可以跟踪`goroutine`调用树上每一个结点。

### 操作实例

```go
func Child(ctx context.Context) {
	for {
		select {
		// 当cancel起作用时就会被select检测到从而调用所对应的操作
		case <-ctx.Done():
			return
		default:
			// 线程进行的操作
		}
	}
}
func main() {
	ctx, cancel := context.WithCancel(context.Background())
	// 生成一个context和一个通知退出的cancel
	go Child(ctx)
	time.Sleep(10 * time.Second)
	// 使用cancel来结束线程
	cancel()
	// 有时候把cancel放在defer中使用
}
```

### 内部原理

要控制线程就需要把这个`context`对象作为参数传进线程的函数中，相当于一个通知者，如果放到`select`中调用这个对象的`Done()`方法的就可以用通道来检测是否有结束信号的传入。当有`cancel`的信号传入的时候就会相当于向通道里传入一个`struct{}`然后就被多路复用检测到起到退出的作用。**所以应该在子线程使用`select`且加入其中一路作为通知控制路，其他路作为操作路**。这个通知可以复用，也就是说可以让多个线程使用，接受通知信号，也可以在父子线程之间共用起到一同结束的作用。

### 多种上下文

对于`context`包中提供的其他的通知对象，这里也做一些说明，目的是要会用。但同样的是`context.Background()`生成的是根结点。

#### 超时通知关闭

之前在没有`context`的时候也可以进行超时线程的关闭，同样是通过扇入扇出的原理来进行的，具体样例如下。

```go
func Do() {
	select {
	// 使用时间包的传入来调用结束线程
	case <-time.After(time.Second * 1):
		fmt.Println("Time out")
		return
	default:
		// 这里执操作代码
	}
}
```

- 使用`context`

```go
func main() {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*10)
	// 虽然这个上下文具有了时间限制的退出，但同样可以主动调用cancel()来退出
	go func(ctx context.Context) {
		select {
		case <-ctx.Done():
			fmt.Println("Time out")
			return
		default:
			// 正常线程运行时的操作
		}
	}(ctx)
	cancel()
}
```

需要注意的是，还有一种`Deadline()`的方式是传入当前时间来计算超时的，普通的超时是从线程开始运行的时候计时。

#### 上下文传值

这就是`context`包的存在意义的第二个方面了，**数据可以通过上下文传递给该树上所有的线程**。对于这种上下文的意义不在于退出，所以没有生成主动调用的`cancel`函数对象。

```go
func Something(ctx context.Context) {
	v, ok := ctx.Value("key").(string)
	// 通过判断可以知道传递进来了值没有
	if ok {
		fmt.Println("%v", v)
	}
}
func main() {
	ctx := context.WithValue(context.Background(), "key", "value")
	go Something(ctx)
	// 省略其他的代码
}
```

这里的传递是使用键值对的方式进行传递，这两个分别都是空接口`interface{}`，所以理论上可以传入任何类型的值。但是需要知道的是，这原意并不是提供了一种传递参数的方法，而是传递一些流程方面控制范围或者线程操作走向的一些数据，不要滥用。

## 细节方面

```go
type Context interface {
	// 这个会返回一个通道去放入一个空接口通知退出
	Done() <-chan struct{}
	// 返回任务取消的原因
	Err() error
	// 返回任务执行的截止时间
	Deadline() (deadline time.Time, ok bool)
	// 根据key拿到存储在context中的value
	Value(key interface{}) interface{}
}
```

> 取消信号沿着树的叶子方向进行，每到一个结点都会像`BFS`一样关闭所有的子结点
> 如果父节点超时取消了，那么子节点也会被取消，而不是不受控制即使还不到取消的条件

### 建议使用方法

1. 不要再结构体内部嵌套一个`Context`
2. 不要将空上下文传递给别的函数，如果不知道传什么，使用内置的`TODO`
3. 上下文被多个`goroutine`使用并发安全

最后还有上面说的，不要把`WithValue()`作为传递数据的方法，而是传递控制类消息或信号。
