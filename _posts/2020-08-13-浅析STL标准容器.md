---
layout: post
title: '浅析STL标准容器'
date: 2020-08-13 22:03:40 +0800
categories: C++
---

`STL`是标准模板库，主要有容器、分配器、算法、适配器、迭代器和函数对象等组成，各类之间互相独立，比如容器和算法互相独立，通过迭代器来沟通。

## 容器

容器有一个非常好的设计理念，从名字上看也十分容易理解，容器`container`用于存放数据的类模板。可变长数组、链表、平衡二叉树等数据结构在`STL`中都被实现为容器。

- 普适性

容器的方法以及容器中容纳元素的方式都使用了**模板类**的定义方法，使用过程中只用考虑容器的元素操作，而不用关心方法是否能够作用于各种各样的元素。

- 标准性

使用标准模板的方法产生的容器自然可以适用于标准库中使用同样标准的函数或者方法，`STL`中的许多算法即函数模板，如排序、查找等算法，在执行过程中会对容器中的元素进行操作，当然有些时候需要重载这些方法来适应特殊的元素。

---

| 顺序容器 |                                                  功能                                                  |
| :------: | :----------------------------------------------------------------------------------------------------: |
|  array   |                         固定大小的数组，支持下标访问，不能添加或者或者删除元素                         |
|  vector  | 可改变数组的大小，支持快速查找，下标查找，但是对于插入和删除操作，需要系统会移动所有元素，效率会比较慢 |
|   list   |              双向链表，不支持下标访问，但是能够双向顺序访问，在任何位置插入删除操作都很快              |
|  deque   |                  双端队列，支持快速访问，类似于一种向量队列，能够添加元素并且两端很快                  |

### 数组

`array`模板定义了一种标准数组的容器类型。基本和数组一致，有类型有个数，不能添加或删除元素。序列容器中的元素严格按照线性顺序排序，各个元素按其顺序进行访问。它的大小是本身属性常量没有内存或时间的编译开销，应该常用`array`来代替数组，这样更安全。

#### 方法

- `max_size()`：返回容器的最大容量

```c++
array<int, 5> number = {1, 3, 2};
cout << number.max_size();
```

- `at()`：访问容器的某个指定元素

```c++
array<int, 5> number = {3, 2, 1, 4, 5};
int a = number.at(3);
// 或者也可以像数组一样随机访问
int b = number[3];
```

- `data()`：返回一个指针指向容器的开头

```c++
array<double, 3> number = {2, 3.0, 1.5};
double *p = number.data();
```

### 向量

`vector`相当于数组可以像数组一样操作，但他的大小可以不确定，所以可以将它看作一种动态数组。可以且只能从后端添加元素，但也会付出代价。因为是线性连续的结构，当空间不够时再扩大就要把数据拷贝到其他足够的内存区域来储存这样会很消耗性能。最好在建立`vector`时就给定一定的空间。极不推荐向中间某个位置添加元素。同样它在指针方面的操作基本和`array`相同。

#### 方法

- `clear()`：清空容器中的所有元素

```c++
vector<int> number{1, 3, 5};
number.clear();
// 只是清空了容器中的元素但没有删除内存空间
int a = number.max_size();
```

- `push_back()`：在容器的最后添加一个元素
- `pop_back()`：在容器的最后删除一个元素

```c++
vector<int> number{1};
number.push_back(3);
number.pop_back();
```

- `insert()`：在某一个位置插入一个元素

```c++
vector<double> number{1.0, 2.0, 3.0};
number.insert(number.begin() + 1, 8.0);
// 把元素添加后，他的位置就是迭代器或指针指向的位置
```

- `resize()`：重新设置该容器的大小
- `reserve()`：重新设置容器的内存大小

```c++
// 前者是直接实际存在的空间，默认0值
// 后者是开辟了内存但是没有存东西
vector<int> number(10){1, 2, 3, 4};
number.resize(4);
number.reserve(100 * sizeof(int));
// 如果之后容器变小，后面的元素会被直接抛弃
```

- `assign()`：向容器中赋入值或者拷贝区间内的值到容器

```c++
vector<long> number{1, 2, 3};
vector<long> cp;
cp.assign(number.begin(), number.end());
number.assign(4, 1);
```

### 链表

`list`是一个线性的链表结构由多个节点构成，每个节点前驱指针指向前一个节点和后驱指针指向后一个节点，具有双向性。因为它存于不连续的内存空间里所以它可以任意伸缩靠指针相连，但也因此它的随机访问能力低下不能用`at()`和数组访问法。也同样因为其结构，向其中添加或删除元素非常高效且影响较小。

#### 方法

- `assign()`：向容器中赋入值或者拷贝区间内的值到容器

```c++
// 链表只能用指针或者迭代器去遍历访问
list<int> number(4, 100);
string word_1[] = {"one", "two", "three"};
list<string> word_2;
word_2.assign(word_1, word_1 + 3);
```

- `insert()`：向某一个位置添加元素

```c++
array<int, 4> number = {{1, 3, 4, 5}};
list<int> cp(number.begin(), number.end()); // 1 3 4 5
cp.insert(cp.begin() + 2, 7);               // 1 3 7 4 5
for (list<int>::iterator it = cp.begin(); it != cp.end(); ++it) {
    cout << *it << " "; // 靠迭代器去访问输出元素
}
// 迭代器和指针并没有明显的界限
```

- `splice()`：将一个`list`中的值移向另一个`list`实现不需要拷贝的拼接

```c++
list<int> frist, seconde;
frist.assign(4, 1);
second.assign(4, 0);
frist.splice(second);
// 1 1 1 1 0 0 0 0
// 之后second将被清空
second.assign(2, 2);
list<int>::iterator it = frist.begin() + 1;
// 可以通过迭代器或者指针来指定插入后的位置
first.splice(it, second);
```

### 双端队列

`deque`是一种对序列两端可以添加元素或删除元素的容器。它同时支持随机访问其中的元素像数组一样。但是在内存存储时，`deque`不像`vector`一样是严格连续的一长串内存空间，它是由多段连续的内存空间组成的，所以向它的两端添加或删除元素并不会太大的性能开销。所以在扩容方面它要比`vector`更加的高效，但这让它在指针方面不能使用如`data()`这样的函数在不确定元素个数时可以使用。不推荐对其中间位置添加元素，虽然代价不如向量严重。

#### 方法

- `resize()`：重新设置该容器的大小
- `reserve()`：重新设置容器的内存大小

```c++
deque<int> number(10){1, 2, 3, 4};
number.resize(4);
number.reserve(100 * sizeof(int));
```

- `push_front()`：在容器的起始添加一个元素
- `pop_front()`：在容器的起始删除一个元素
- `push_back()`：在容器的最后添加一个元素
- `pop_back()`：在容器的最后删除一个元素

```c++
deque<int> number{1, 3, 4};
number.push_front(5);
number.push_back(4);
// 加上后缀front和back即可控制加入和弹出的位置
```

### 栈

`stack`一种先进后出的数据结构，常被用于内存管理。同时栈也可以利用这种性质来构建单调栈来处理问题。

#### 方法

- `top()`：返回栈顶的元素

```c++
stack<int> number{1, 2, 3, 4};
int a = number.top(); // a == 1
```

- `push()`：在栈顶加入一个元素
- `pop()`：在栈顶弹出一个元素

```c++
stack<int> number;
number.push(1);
number.push(2);
number.pop();
// 根据栈的数据结构特征添加和弹出元素
```

---

| 关联容器 |                                  功能                                   |
| :------: | :---------------------------------------------------------------------: |
|   map    |   关键字起到索引的作用，值则表示与索引相关联的数据，可以称作关联数组    |
|   set    | 每个元素唯一，可以这么认为，其实 set 就是一个集合，用来存储同类型的元素 |

### 图

`map`是一种关联容器，它存储关键字，每个关键字只能出现一回，所以其中元素必须唯一。`map`中用红黑树，并且在树种的元素被排序，所以内部数据是有序的，由于一一对应的特点，其具有较强的关键字处理能力。它在完成一些检索一对一数据时能够提高效率，自动建立`key`和`value`的关联，所以向里面通常插入一个`pair`数据。

#### 方法

- `insert()`：向某一个位置添加元素

```c++
map<int, string> man;
man.insert(1, "Jack");
man.insert(make_pair(2, string("Alan")));
man.insert(pair<int, string>(3, "Colin"));
// 也可以把元素用对的形式插入到图中
```

- `at()`：根据`key`的值来访问其中元素也可用`[]`

```c++
// 成员函数at的参数是键值
map<int, string> people;
people.insert(pair<int, string>(3, "Colin"));
people.insert(make_pair(2, "Alan"));
// 使用at
people.at(3);
// 使用下标符号[]
people[2];
// 返回的值不是键值，而是和键值绑定在一起的值
```

- `find()`：函数检索`key`返回一个指向相应元素的迭代器

```c++
man.find(100)
// 会返回查找到的迭代器，查不到会返回零值
```

### 集合

`set`是通过红黑树实现，类似于数学中集合的一种容器。其中的每一个元素都是唯一的否则需要用`multiset`。因为它的数据结构的原因，对其中元素检索效率要高过其他序列容器。`set`中所有元素都是靠节点来储存，其节点指向父节点和子节点，节点结构类似于链表。

#### 方法

- `insert()`：像容器中插入元素
- `erase()`：从容器中擦除一定区间的元素，或者擦除特定元素

```c++
set<int> number{1, 2, 3, 5};
number.insert(4);
number.erase(3);
```

- `find()`：从容器中查找某元素并返回指向它的迭代器

```c++
set<int> number{1, 2, 3, 4};
set<int>::iterator it = number.find(3);
// 只能用find因为无序容器中的元素无法被直接访问
```

## 迭代器

对于`STL`来说，如果要访问容器中的元素则需要通过迭代器来实现，相当于容器和操纵容器的算法之间的中介，其作用和指针差不多。

### 迭代器分类

- 正向迭代器

```c++
container::iterator it;
```

- 常量正向迭代器

```c++
container::const_iterator it;
```

- 反向迭代器

```c++
container::reverse_iterator it;
```

- 常量反向迭代器

```c++
container::const_reverse_iterator it;
```

### 迭代器的使用

> 对正向迭代器进行++操作时，迭代器会指向容器中的后一个元素
> 而对反向迭代器进行++操作时，迭代器会指向容器中的前一个元素

因为迭代器就相当于一种适用于容器的特殊指针，所以使用方面同样可以像指针一样操作指向或者`++`自加自减。

- 正向迭代器

如果是正向迭代器，那么它可以有指针的基本**自增**操作，并且同类型的迭代器还可以相互赋值，相互比较。

- 双向迭代器

双向迭代器有正向迭代器的所有功能，并且可以自由**自增自减**。有`list`、`set`和`map`等采用了双向的迭代器。

- 随机访问迭代器

随机访问迭代器是双向迭代器的超集，它支持了**非自增自减**的跳跃式的访问，是很多支持随机访问的容器的迭代器类型如`vector`和`deque`等。

### 迭代器函数

迭代器作为一个`STL`中不可或缺的部分，自然也有针对的函数对其进行操作。

|   函数名    |                                      功能                                      |
| :---------: | :----------------------------------------------------------------------------: |
|  advance()  | 两个参数，分别是迭代器和一个数字，可以达到移动迭代器向前或者向后一定数量的元素 |
| distance()  |             计算两个迭代器之间的距离，如果已经在之前则会陷入死循环             |
| iter_swap() |    可以快捷的交换两个迭代器指向的元素的值，普通的`swap()`交换的是迭代器的值    |

### 遍历容器

虽然各个容器的数据结构不一样，遍历元素的方式不一样，但是用迭代器遍历不同容器的代码是完全一样的。迭代器一般实现为容器的嵌套类型，在容器内部提供具体的实现。是因为迭代器提供了常用的`operator!=`、`operator++`、`operator\*`等运算符的重载函数，把迭代容器的细节全部隐藏在这些通用的运算符重载函数里面，因此用户侧表现出来的就是，迭代器遍历所有容器的方式都是一样的。

#### 使用简循环

这种是`C++11`新标准下的`for`循环遍历，其实底层就是用的迭代器的自增运算实现的，实质上和下面的方法一致。

```c++
map<int, string> account;
for (auto it : account) {
  // 其中的迭代器不断指向元素
  if (it.frist) {
    // 如果目前的键值对存在
  } else {
    // 反之键值对不存在
  }
}
```

#### 正常遍历

正常的声明一个迭代器变量并进行操作，非常常见的作法。

```c++
vector<int> vec;
for (vector<int>::iterator it = vec.begin(); it != vec.end(); it++) {
  // 省略代码
}
```
