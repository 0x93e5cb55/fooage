---
layout: post
title: '深入C++继承派生'
date: 2021-01-27 16:35:47 +0800
categories: C++
---

一个新类从已有的类那里获得其已有特性，这种现象称为类的继承。通过继承，一个新建子类从已有的父类那里获得父类的特性。从另一角度说，从已有的类产生一个新的子类，称为类的派生。类的继承是用已有的类来建立专用类的编程技术。派生类继承了基类的所有数据成员和成员函数，并可以对成员作必要的增加或调整。

## protected 和 private 的区别

对于类外的成员，这两个都是无法被访问的。而对于其派生类而言，`protected`可以继承的，`private`在什么情况都是无法被其他类访问或继承的。

## 深浅拷贝

在类的拷贝过程中有两种拷贝，一种是靠编译器普通的拷贝，一种是靠拷贝构造函数自己定义的拷贝。主要用于解决拥有堆内存的类内指针重复释放或者同时指向某一内存空间的问题。拷贝构造函数是一种特殊的构造函数，**只有在构造对象的时候才会被调用**。

### 浅拷贝

```c++
class Person {
  private:
    int age;

  public:
    Person() {}
    Person(int a) : age(a) {}
    ~Person() {}
}
```

浅拷贝主要靠的是默认的拷贝函数，值得注意的是这个拷贝函数是遵循**值拷贝**的规则，这样就有可能把指针的值拷贝后指向同一块内存空间，为了避免这种情况的发生就有了下面的深拷贝。

```c++
Person b(a);
// The compiler helps construct the copy constructor.
```

### 深拷贝

```c++
Person::Person(int a) { p = new int(a); }
// Heap memory, manually opened, manually released.
Person::~Person() {
  delete p;
  p = NULL;
}
```

- 注意

如果在直接对带有动态内存的类进行浅拷贝，但是其中维护堆内存的指针指向了同一地址，会导致同一内存地址被释放两次。所以我们要用深拷贝来避免两者同时只想统一地址。

```c++
class Person {
  private:
    int *p;

  public:
    Person(int);
    Person(const Person &);
    ~Person();
}
```

```c++
Person::Person(int a) { p = new int(a); }
Person::Person(const Person &b) {
  p = new int(*b.p);
  // De-reference the pointer to get the value of the pointer, so that the
  // copied class reapplys for a memory chunk of the same value, copying only
  // the value, not the address.
}
Person::~Person() {
  delete p;
  p = NULL;
}
```

## 继承中的指针运用

派生类的指针不能够指向基类，而基类的指针可以指向派生类，即**不能将指针往上追溯**。

```c++
// Yes!
StudentPlus s();
Student *p = &s;
```

---

```c++
// No!
Student s();
StudentPlus *p = &s;
```

### 静态联编

虽然派生类对象或者指针可以赋值给基类的对象或者指针，但是函数的调用关系已经确定了，基类的对象和指针调用的函数都是基类的函数不会因为赋值而发生改变。

### 动态联编

即为**多态**，当想用基类对象或者指针来调用赋值过后的的新的函数，这时候就要把函数定义为**虚函数**，这样在赋值的时候就可以将函数指针的指向重置，来指向新的函数。当然这样的函数继承之后还是虚函数，一直保持这种“虚构”的状态。**指针或引用赋值的时候才能覆盖虚函数**，对于对象的直接赋值只会把对象的数据进行赋值，而不会影响到对象的函数表，指针和引用则可以深层次的影响虚函数表。
