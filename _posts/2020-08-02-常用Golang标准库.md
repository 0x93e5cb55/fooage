---
layout: post
title: '常用Golang标准库'
date: 2020-08-02 22:47:20 +0800
categories: Golang
---

这里是一些非常常用的标准库的一些记录解析，有时候不需要重复造轮子，而是只需要使用现成的标准库就可以了。`go`从普通操作到网络开发都有一些好用的内置包可以使用。

## `time`

### 时间操作

#### 获取时间

通过生成一个新的当前时间对象我们可以获取当前时间。然后通过这个时间对象的方法我们可以获得当前的各种时间的信息。

```go
now := time.Now()
loc, err := time.LoadLoacation("Asia/Shanghai")
// 设置当前时区
if err != nil {
    return
}
// 生成了一个现在时间的对象
```

---

|   方法   | 效果 |
| :------: | :--: |
|  Year()  | 年份 |
| Month()  | 月份 |
|  Day()   |  日  |
|  Hour()  | 小时 |
| Minute() | 分钟 |
| Second() |  秒  |
|  Date()  | 日期 |

#### 时间戳

时间戳是一个很有意思的量，它的值是 1970 年 1 月 1 日（08：00：00GMT）到当前时间的总毫秒数，也叫做`Unix时间戳`。当然包里面也有获得当前时间戳的方法。

```go
now := time.Now()
now.Unix()     // 返回现在时间戳
now.UnixNano() // 返回纳秒精度的时间戳
```

### 时间的运算

#### 相加

```go
now.Add(time.Second) // 现在的时间加一秒
```

在`Go`时间报源码中有很多的时间间隔的常量定义了标准时间。

```go
const (
	Nanosecond  Duration = 1
	Microsecond          = 1000 * Nanosecond
	Millisecond          = 1000 * Microsecond
	Second               = 1000 * Millisecond
	Minute               = 60 * Second
	Hour                 = 60 * Minute
)
time.Duration // 是标准的一毫秒，是其他时间的单位构成
```

#### 相减

```go
now.Sub(tmp) // 以现在的时间减去某一个时间返回一个时间段
```

#### 相等

虽然时间时间之间可以直接进行赋值比较，但是这种用方法的方式比较严谨，他还考虑到了地点时区等问题。

```go
now.Equal(now)
```

还有两种返回布尔值的方法可以调用，来判断时间的先后，效果就是字面意义上的。

-   `Before`
-   `After`

### 格式化

#### 时间格式化

顾名思义，就是格式化时间，在日志操作里面比较有用。但也有标准日志库可以使用，即便如此也要了解。还需要知道`Go`中的格式样式不是年月日时分秒，而是`2006`年`1`月`2`号`15`点`04`分所以我们以这个时间去作为标准格式去让编译器识别是何种格式。

```go
now := time.Now()
fmt.Println(now.Format("2006/01/02 15:04"))
// 这样在打印当前时间时就会变成
// 2020/04/11 22:53
// 非常有意思的格式化
```

#### 解析格式化

与格式化时间相反的，我们得到一个时间字符串，我们要用某一种格式去把字符串里面包含的时间信息给读出来，所以我们需要解析格式化时间。

```go
timeObj, err := time.ParseInLocation("2006/01/02", "2020/04/11")
// 通过给出的格式，解析后面的字符串
// 解析后的时间会返回到时间对象中
```

## `strconv`

`Go`语言的类型性要比`Java`和`C++`强一些，对于同一类类型可以通过强制类型转换，而对于不太相干的类型不能直接转换，需要用到`strconv`包中的一些方法来进行字符串相关的转换。

```go
i := int32(97)         // 强制类型转换
fmt.Println(string(i)) // 结果按照码表转换成了字母
fmt.Sprintf("%d", i)   // 这样转换成了数字字符串
```

解析字符串的数据信息的时候就这个包里面的方法了。

### 类型转换

#### 值类型转换

把字符串转成整型，把整型转成字符串。首先需要理解`A`或`a`的含义，因为在`C`语言中字符串是字符数组`array`实现的，所以`A`和`a`就成了字符串的代表而不是`s`，所以下面的就很好理解了。

-   `Atoi()`

把字符串转为整型。

```go
i := strconv.Atoi("10000")
```

-   `Itoa()`

把整型转成字符串。

```go
s := strconv.Itoa(10000)
```

#### 解析字符串

-   `ParseBool()`

> "1"和"0"
>
> "t"和"f"
>
> "T"和"F"
>
> "true"和"false"
>
> "True"和"False"
>
> "TRUE"和"FALSE"

以上字符串可以被解析成布尔值。

```go
ok, err := strconv.ParseBool("true")
```

-   `PraseInt()`
-   `PraseUint()`

```go
tmpInt, err := strconv.ParseInt("10000", 10, 64)
// 第二个参数是原字符串进制，如果为0则会按字符串前置判断"ox"和"o"默认十进制
// 第三个参数是转成的数存储的大小，分别对应各种int
```

-   `PraseFloat()`

没有了进制的那个参数，只要字符串符合标准，则会被转成浮点类型，至于精度要取决于之后储存的那个变量的精度的大小。

```go
tmpFloat, err := strconv.ParseFloat("3.1415", 64)
// 最后以64位浮点数存储
```

#### 数值转字符串

通过解析字符串能够得到数值类型，那么通过格式化数值类型也可以得到相应的字符串。语法大致和解析`Parse`差不多。

-   `FormatBool()`

```go
// 返回"true"和"false"
s := strconv.FormatBool(1)
```

-   `FormatInt()`
-   `FormatUnit()`

```go
tmpInt := strconv.FormatInt(123, 10)
// 只需要标明进制就行了
```

-   `FormatFloat()`

需要加上一个格式标识来标记小数的进制，有各种英文字母代表。还有精度的设置，这是不同于其他格式化的。

| 格式标记 |                 效果                 |
| :------: | :----------------------------------: |
|    f     |            （-ddd.dddd）             |
|    b     |     （-ddddp±ddd，指数为二进制）     |
|    e     |      (-d.dddde±dd，十进制指数）      |
|    E     |     （-d.ddddE±dd，十进制指数）      |
|    g     | （指数很大时用’e’格式，否则’f’格式） |
|    G     | （指数很大时用’E’格式，否则’f’格式） |

还有精度控制的数字，如果是`-1`则表示只用必要的数字字符表示出来该数字，如果是其他数字，那么就会强制往小数点后推一些数字的精度来填充字符串。

```go
tmpFloat := strconv.FormatFloat(3.1415926, 'E', -1, 64)
```

## `flag`

当写出脚本程序直接靠后缀参数运行的时候常常需要获取后面的参数，之前`os.Args`就可以获得执行时后缀参数。但是遇到一些复杂的情况就需要利用`flag`包来获取和处理参数。

### 系统参数

```go
// 运行时使用.\xxx.exe 参数
func main() {
	os.Args // 单独一个就可以获得所有的参数，按顺序以字符串类型储存在切片中
	a := os.Args[0]
	// 可以访问字符串切片中的参数
}
```

`flag`包支持多种命令行参数，`bool`、`int/int64/uint`、`float/float64`、`string`、`duration`（时间段）以上参数必须合法才能使用。

### 解析参数

> `flag.Type()`的参数列表为参数名，默认值，帮助信息
>
> `flag.TypeVar()`的参数列表为类型指针，参数名，默认值，帮助信息

```go
flag.string("args", "0", "enter the number args") // 返回参数指针
// 定义一个字符串参数
flag.IntVar(&level, "level", 4, "enter the number args") // 返回参数变量
// 定义一个整型参数
```

在定义完参数之后要解析参数，使用`flag.Parse()`来解析参数，解析参数支持以下的参数格式。

1. `-flag xxx`
2. `--flag xxx`
3. `-flag=xxx`
4. `--flag=xxx`

在调用的时候按照这样输入参数就可以让程序获得参数。同样也可以通过方法像`os.Args`一样获得所有参数的字符串切片使用`flag.Args`方法去获取，返回一个字符串切片，包含所有**参数值**的字符串。

```go
flag.Args() // 效果基本和os.Args的相同
```

如果用表明参数名赋值的方法去获得参数，而是直接后跟参数值，如何实现读取参数很关键。

```go
var a = flag.NArg() // 返回除指定函数名直接赋值的参数的参数数量
for i := 0; i < a; i++ {
    // 实现不知道数量的情况下使用参数
}
```

-   使用的参数的数量。

```go
flag.NFlag() // 获得当前被使用的函数数量
```

## `log`

对于后台程序来反映自己的运行状况主要靠的就是日志输出，不管是向文件的输出还是标准终端的输出`Go`语言都提供了一个比较简单的日志包实现了事件的描述，日志的分级，精确的事件，文件的写入等功能。

### 配置日志

通常情况下日志不只需要记录时间，而且还需要记录一些自定义的更加详细的内容，可以用设定`Flags`来自定义日志的输出，这时需要使用`SetFlags`函数来设置。

```go
const (
	Ldate         = 1 << iota     //  日期
	Ltime                         //  时间
	Lmicroseconds                 //  微秒级别的时间
	Llongfile                     //  显式文件全路径名+行号
	Lshortfile                    //  文件名+行号
	LUTC                          //  使用UTC时间
	LstdFlags     = Ldate | Ltime //  标准logger的初始值
)
```

这里随便演示如何加入更详细的参数，直接使用常量即可，可以使用`|`来多个使用就像文件打开方式一样。

```go
log.SetFlags(log.Ldata | log.Ltime | log.Lshortfile)
// 这样再用log输出就会显式上面定义的信息
```

### 书写日志

#### 标准输出

对于向终端输出的临时日志用的是标准输入输出。一共有有三个等级可以使用。

> `INFO`类

-   `Print|Printf|Println`

> `PANIC`类

-   `Panic|Panicf|Panicln`

> `FATAL`类

-   `Fatal|Fatalf|Fatalln`

通过这几个预制好的`logger`就可以完成简单的日志输出，`PANIC`类的日志和`Panic()`具有相同的特征可以被捕获，唯一不同就是会输出日志信息，还有`FATAL`类的日志输出的同时会直接退出程序相当于`os.Exit()`。

```go
defer recover()
// 使用标准日志
log.Panicf("%s", "A panic happened")
```

#### 日志文件

需要将日志记录到文件长期保存的时候就需要文件输入输出，通过一个`io.Writer`来给日志定位，之后的日志都会存入到指定的文件中，**文件输入输出中的标准输出还有缓冲输出的文件对象都可以作为参数填入**。

```go
file, err := os.OpenFile("./text.log", os.O_CREATE|os.O_APPEND, 0644)
// 获得一个文件对象来指向文件
log.SetOutPut(file)
```

设置完毕之后就可以在标准输出的同时文件写入到日志文件当中了。

### 自定义日志

前面的方式都是通过内置的`logger`进行操作的，还可以生成自己的`logger`来区别使用。大体上看就是通过日志对象的构造函数来生成日志对象，然后给新日志对象加入日志参数。

> `func New(out io.Writer, prefix string, flag int) *Logger`

由参数列表可以知道，首先要定义日志的输出方法，然后定义日志的前缀，最后一个参数就是日志的`Flags`。

```go
myLogger := log.New(os.Stdout, "[MyLog]", log.Ldate|log.Ltime)
```

通过这个日志对象使用方法就会从完成后面的描述项。

## `strings`

字符串因为是以原生类型的形式出现在`Go`语言中，所以他常被视为一个整体，要更改某一字符的值时需要进行切片，而不能直接通过字符数组来随机访问里面的字符。

> 1byte = 8bit

普通的数字和英文字母都可以用一个字节来表示，但是对于复杂语言如汉字，则需要更多的编码位数，一个`UTF-8`汉字一般三个字节。

### 基本操作

-   字符串拼接

```go
a := "w"
b := "rk"
c := a + b
// 简单的相加
```

-   字符串比较

```go
a := "asdf"
b := "qwer"
if a > b {
    // 可以直接用运算符比较
}
```

### 字符串方法

-   字符串分割

```go
var str string = "asdfasdf"
strSlice := strings.Split(str, "s")
// 把字符串从s字母处分割
// 修改为"a dfa df"
// 注意这种返回的是字符串切片
```

-   字符串包含检查

```go
str := "asdfasdf"
var has bool = strings.Contains(str, "fa")
// 如果包含则返回1，如果不包含返回0
has = strings.ContainsAny(str, "sa")
// 如果子串中任意一个存在则返回1，反之则0
```

-   字符串查找

```go
var str string = "abcdef"
find := strings.Index(str, "d")
// 从前查找，会返回第一次查找到的子串的索引
find = strings.LastIndex(str, "e")
// 从后查找，会返回第一次查找到的索引
find = strings.IndexRune(str, "王")
// 查找一个Rune型的子串
```

-   字符串重复

```go
var str string = "abc"
str = strings.Repeat(str, 3)
// 重复字符串n次
```

-   大小写转换

```go
str := "abc"
str = strings.Title(str)
// 首字母大写，标题形式
str = strings.ToLower(str)
str = strings.ToUpper(str)
```

## `bufio`

这是一个处理`I/O`的包，它有很强的通用性，可以适用于很多的数据对象来读取信息很简洁也很可靠。`bufio`是通过缓冲来提高效率。简单的说就是，把文件读取进缓冲内存之后再读取的时候就可以避免文件系统的读写从而提高速度。

### 读取

通过`bufio.Reader`，我们可以从底层的`io.Reader`中更大批量的读取数据。这会使读取操作变少。如果数据读取时的块数量是固定合适的，底层媒体设备将会有更好的表现，也因此会提高程序的性能。

> io.Reader --> buffer --> consumer

#### 创建对象

使用构造函数来创建一个用于读取对象，这个读取对象有相应的方法进行读取操作

```go
file, err := os.Open("demo.txt")
if err != nil {
    return
}
defer fileObj.Close()
reader := bufio.NewReader(file)
// 这样创造了一个读取对象可以用于读取对应的对象数据
```

-   设定缓冲区大小

默认的缓冲区大小是`4096`，那么如果要生成指定缓冲去大小的对象就要用另一种构造函数。

```go
reader := bufio.NewReaderSize(file, 1024)
```

#### 读取数据

因为有了缓存区，所以在这个`reader`创建的时候就已经将数据转入了缓存区中了，可以直接从缓存区中取出这部分数据。

-   当缓冲区空间小于等于容器长度

> 直接跳过缓存，直接从底层`io.Reader`中读取到容器

-   当缓冲区空间大于容器长度

> 读入到缓存中，之后找机会存入

```go
cnt, err := reader.Read(buf)
buf, err := reader.ReadBytes()
// 可以加入界定符的参数来停止读取，但包括界定符
str, err := reader.ReadString()
```

如果还没有到**界定符**就已经出现了一个错误，那么会返回已经读取到的数据和这个错误，比如出现了文本结尾的标记或者缓冲去已经读满了。

-   `Peek`

有时候可以不取出数据直接抽查一部分缓冲区内的数据。

```go
buf, err := reader.Peek(24)
// 从缓冲区中先读出24个字节的数据
```

### 写入

写入数据使用过`Writer`来实现的，同样也提供了缓存功能。

#### 创建对象

创建一个实现了`io.Writer`接口的写入对象，同样是有两种方法的，一种就是默认的另一种是指定缓冲区大小的。

```go
file, err := os.Open("demo.txt")
if err != nil {
    return
}
defer fileObj.Close()
writer := NewWriter(file)
// 或者指定缓存区大小
writer := NewWriterSize(file, 64)
```

#### 写入操作

写入操作的时候利用缓存区的方法都会有以下的判断方法来防止出错。

-   当缓冲区空间小于要写入长度

> 当缓存区为空，则直接写入
>
> 不为空时，首先把缓冲区填满后全部写入

-   当缓冲区空间大于等于要写入长度

> 先暂存在缓冲区后找机会写入

```go
cnt, err := writer.Write(buf)
if err != nil {
    return
}
```

### 接口化底层

其实不只是文件的读写操作，对于各种数据的读写都有一个核心的底层接口`io.Reader/io.Writer`。很多方面的读写操作的方法或者对象都是实现了这个接口，这也在很大程度上实现了泛型的编程增加了通用性。

```go
type Reader interface {
	Read(p []byte) (n int, err error)
}
type Writer interface {
	Write(p []byte) (n int, err error)
}
```

实现了这个接口的部件有很多，只不过没有深究，其实在很多时候都显式或者隐式的被使用着。

> `net.Conn`,`os.Stdin`,`os.File`：网络、标准输入输出、文件的流读取
>
> `strings.Reader`：把字符串抽象成读取对象
>
> `bytes.Reader`：把`[]byte`抽象成读取对象
>
> `bytes.Buffer`：把`[]byte`抽象成`Reader`和`Writer`对象
>
> `bufio.Reader/Writer`: 抽象成带缓冲的流读取
