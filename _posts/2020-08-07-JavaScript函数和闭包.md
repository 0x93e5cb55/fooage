---
layout: post
title: 'JavaScript函数和闭包'
date: 2020-08-07 18:15:22 +0800
categories: JavaScript
---

函数是为了解决重复的固定运算步骤的问题产生的，一个函数固定解决一类问题。函数的封装是把一个或者多个功能通过函数的方式封装起来，每次只用调用函数而不是重写或者了解具体的运算内容。在`JavaScript`中**函数是一等公民**。函数的使用方法有很多，甚至可以起到面向对象继承的效果。

## 函数解析

对于`JS`来说函数的声明方法多样，并且运用语法灵活。主要由以下这么几种使用方法，也许有一些比较偏门的方法就不写了。

1. 和其他语言一样的声明和表达
2. 将匿名函数变量赋值给某个变量调用
3. 还有直接调用的匿名函数

### 具名函数

这样声明函数函数的作用域是全局的，在`JS`代码块的任何位置都可以调用该函数。

```javascript
// 关键字加上正常的命名方式
function add(a, b) {
    return a + b
}
```

> 如果是浏览器则会在`window`全局作用域中。

#### 小细节

函数要有返回值，如果没有显式的写出返回值那么直接视为返回`undefined`。还可以像下面这样构造函数的调用。

```javascript
function fun(arg) {
    this.name = arg
}
//  调用函数
var x = new fun('Wong')
console.log(x.name)
// 已经是视为是一个对象了
```

### 匿名函数

匿名函数可谓是`JavaScript`中函数式编程的精髓，它的运用方法丰富且运用场景广泛。

#### 作用域

这里就要提一下`JS`这种语言中的作用域了，因为在这种脚本语言中没有块级作用域，导致普通的**大括号并不能将作用域区分开来**，但是在函数中，函数就是一个相对封闭的作用域。

```javascript
for (let i = 1; i < 10; i++) {
    a = 0
}
// 块级区域外依旧是a的作用域
console.log(a)
```

但是如果在函数中就一定能够保证作用域么？答案是声明变量的时候要记住规范。

```javascript
function fun() {
    a = 10
}
// 不使用var或者let声明是伪全局变量
console.log(a)
```

-   记着要用`var`或者`let`关键字否则会默认全局

#### 运用匿名函数

声明匿名函数和它的运用分不开，通常是下面几种方法。

```javascript
var fun = function (a, b) {
    return a + b
}
// 这时候通过变量来调用，其实是函数对象
let c = fun(1, 2)
```

#### 箭头式函数

还有一种在`NodeJS`中非常常见的函数的语法格式是通过箭头由函数参数列表指向表达式。

```javascript
// 匿名函数的参数列表
var fun = (a, b) => {
    return a + b
    // 匿名函数的表达式
}
```

当然这种方式也不是没有区别，**箭头函数没有默认`this`指针**。而且在万物皆对象的`JS`中，它并不能够作为构造方法来使用`new`关键字。

## 闭包的使用

函数闭包在具有匿名函数的语言中普遍存在，它是**环境和函数表达式的结合**。

```javascript
function foo() {
    var local = 1
    // 外部上下文环境
    function bar() {
        console.log(local)
    }
    return bar
}
```

### 闭包与上下文

闭包不能滥用，因为匿名函数如果不是`IIFE`即立即执行的话就会不断引用外部的变量。

```javascript
var funs = []
for (let i = 0; i < 3; i++) {
    // 保存闭包函数
    funs.push(function () {
        console.log(1)
    })
}
funs[0]() // 2
funs[1]() // 2
funs[2]() // 2
```

为了让值立即赋值给闭包函数而不是不断地引用，可以使用立即执行的函数来包裹住闭包，并把外部变量通过参数传递给闭包函数。

```javascript
var funs = []
for (let i = 0; i < 3; i++) {
    // 保存闭包函数
    funs.push(
        (function (n) {
            // 生成的是有稳定外部环境的闭包
            return () => {
                console.log(n)
            }
        })(i)
        // 将上下文环境立即不变的传入
    )
}
funs[0]() // 0
funs[1]() // 1
funs[2]() // 2
```

所以闭包的引用上下文环境要尽可能的稳定，如果做不到那么要采用外套函数的方式让闭包外的环境变成函数参数提供的稳定环境。
