---
layout: post
title: 'C++多态和重载'
date: 2020-08-13 16:39:10 +0800
categories: C++
---

多态和重载在实际运用中是非常重要的部分，多态实现了代码的重用，重载提供了函数或运算符的多样性。

## 虚函数和抽象类

虚函数是被`virtual`关键字修饰的成员函数，用来实现继承中函数的多态性。通过不同的环境来使用不同的同名函数，实现类之间类似于普通函数的重载。

### 引入目的

`C++`允许基类和派生类之间的直接转化，但这也造成了一些函数调用的混乱，比如父类调用了子类的同名函数，子类错误调用了父类的同名函数，为了避免基类和派生类同名成员函数的错误调用问题。

```c++
// 错误
class Base {
  public:
    void print() { cout << "Base!" << endl; }
};
class Derive : public Base {
    void print() { cout << "Derive!" << endl; }
};
int main() {
    // 如果用不同的类对象调用函数则一切正常
    // 如果使用指向基类的指针就会出现冲突
    Base a;
    Derive b;
    Base *p1 = &a;
    Base *p2 = &b;
    p1->print(); // 输出Base!
    p2->print(); // 输出Base!
                 // 明明指向派生类却错误调用了基类的成员函数
}
```

这种情况的发生是因为函数的静态多态是早绑定，函数的地址是在编译阶段绑定给调用，这样因为函数一开始是父类对象，所以绑定的是父类的对象的函数，出现错误。

-   为了解决基类生成对象的不合理性

手动的多态，可以从派生类中解释提供基类的函数的实例。

-   为了提高编码的效率方便对代码的重构

这个在纯虚函数中体现比较明显，纯虚函数在基类函数中没有实现，在派生类中如果不提供实现则会报错，但是这也给了一个方便使用多态特性的方式。

### 使用虚函数

#### 虚函数

```c++
class Base {
  public:
    virtual void print() { cout << "Base!" << endl; }
    // 加上前缀变为虚函数
};
class Derive : public Base {
    void print() { cout << "Derive!" << endl; }
};
// 这样定义之后在指针调用下就会正常使用派生类的同名函数
```

加上前缀之后，函数列表中虚函数就变“虚”了，实现了动态的多态，派生类`重写`了基类中的虚函数之后，派生类的同名函数可以在函数表中将基类中的虚函数在指向派生类的基类指针调用时把原来对应的基类函数`同名覆盖`，这样就会调用派生类的函数。

> 重写：名字、参数列表都相同
>
> 重载：名字相同，参数列表不相同

#### 纯虚函数

纯虚函数时在基类中声明的虚函数，但是在基类中并没有定义，但要求任何派生类都要定义自己的实现方法，在基类中定义虚函数的方法时在函数声明后加`=0`。

```c++
class Base {
  public:
    virtual void print() = 0;
};
class DeriveA : public Base {
    void print() { cout << "Derive A!" << endl; }
};
class DeriveB : public Base {
    void print() { cout << "Derive B!" << endl; }
};
class DeriveC : public Base {
    // 如果纯虚函数在派生类中得不到实现，就会报错
}
```

在这么实现虚函数时，子类的子类或者孙子类都可以覆盖该虚函数，调用的时候就会根据多态方式动态绑定使用合适的函数。

### 抽象类

当一个类中具有虚函数时，无法`实例化`是一个抽象类，抽象类一般是对象的一些基本特征，但是它一般作为基类不单独使用。由于纯虚函数的使用，在抽象类中不必具有函数的实现，只需要利用虚函数的性质，在他所派生出来的类中实现符合这些派生类应用实际的函数实现即可。

#### 抽象类使用

```c++
class Base {
  public:
    virtual void fun() = 0;
};
// 省略代码
Base a; // 报错因为不能够被实例化
```

## 类运算符重载

运算符重载是一种形式的多态，函数的多态及是它的重载。但是在类中的重载可以扩展到运算符上。例如我们可以扩展运算符`+`的运用范围。因为普通的运算符对类型的重载只限于基本的内置类型如`int`等，而实际应用过程中为了简洁需要让普通运算符有更多的适配性。

### 重载原则

> 重载不能改变参加运算的对象个数
>
> 重载不能改运算符的优先级别
>
> 重载函数不能有默认的参数
>
> 重载不能改运算符的结合性
>
> 重载运算符中至少有一个操作是定义类
>
> 对运算符的重载不能完全背离原意
>
> 可以设置结果对象来防止对值的修改

### 普通重载运算符

#### 重载方法

使用`operator`加上要重载的运算符，类似于方法的声明。而在重载后的运算符就会被附上另一种定义去扩展它的用法使其拥有其他更细致定制化的运算规则。

> 左侧是运算符调用对象
>
> 右侧是传入值的对象

```c++
void Time::Add(int h, int m) {
    hours += h;
    minutes += m;
    if (minutes >= 60) {
        minutes = minutes % 60;
        hours++;
    }
}
void Time::Sub(int h, int m) {
    if (h * 60 + m > hours * 60 + minutes) {
        cout << "Error!" << endl;
        return;
    }
    hours -= h;
    minutes -= m;
    if (minutes < 0) {
        hours--;
        minutes = 60 + minutes;
    }
}
void Time::Show() { cout << "Time: " << hours << ":" << minutes << endl; }
Time Time::operator+(Time b) {
    // 和上面的方法相比，重载后的运算符能够自定义运算规则
    // 比如进行对象之间的运算，对象元素之间的运算
    Time a;
    a.hours += b.hours;
    a.minutes += b.minutes;
    if (a.minutes >= 60) {
        a.minutes = a.minutes % 60;
        a.hours++;
    }
    return a;
    // 返回运算结果，这是运算的根本属性之一
}
// 定义重载运算符的书写有别与其他方法
const &Time Time::operator-(const &Time b) const {
    Time a;
    // 要实现两个对象的运算就只能在重载方法内写入两个对象
    if (a.hours * 60 + a.minutes < b.hours * 60 + b.minutes) {
        cout << "Error!" << endl;
        return;
    }
    a.hours -= b.hours;
    a.minutes -= b.hours;
    if (a.minutes < 0) {
        a.hours--;
        a.minutes = 60 + a.minutes;
    }
    return a;
}
```

因为有`this`指针可以指向本对象，所以重载运算符还有另外一种写法。

```c++
Time Time::operator-(Time &other) {
    if (this->hours * 60 + this->minutes < other.hours * 60 + other.minutes) {
        cout << "Error!" << endl;
        return;
    }
    this->hours -= other.hours;
    this->minutes -= other.hours;
    if (this->minutes < 0) {
        this->hours--;
        this->minutes = 60 + this->minutes;
    }
    return *this;
    // 注意this是指针，可以用*this来代表指针指向的对象
}
```

#### 解析

在重载时二元运算符会有左操作数和右操作数，一般将后者作为重载后运算符的传递的参数，前一项在方法内声明并对他们进行操作。这样的作法就模拟了二元运算符的运算过程，并且我们应该注意的是在运算时的值属于哪个对象，进行区分。

#### 重载效果

```c++
// main.cpp
#include "../inc/time.h"
#include <iostream>
// 使用之前要引用
using namespace std;
// 省略代码
Time a(1, 32);
Time b(2, 41);
Time c;
c = a + b;
// 运算结果被返回并被c对象接受
c.Show();
// 输出结果
// Time: 4:13
```

#### 重载的界限

以下的运算符不能重载：

> `sizeof`大小运算符
>
> `.`成员运算符
>
> `.*`成员指针运算符
>
> `::`作用域解析运算符
>
> `?;`条件运算符
>
> `typeid`一个 RTTI 运算符
>
> `const_cast`强制类型运算符
>
> `dynamic_cast`强制类型转换运算符
>
> `reinterpret_cast`强制类型转换运算符
>
> `static_cast`强制类型转换运算符

以下的运算符只能通过成员函数进行重载：

> `=`赋值运算符
>
> `()`函数调用运算符
>
> `[]`下标运算符
>
> `->`通过指针方位类成员运算符

### 友元运算符重载

通过友元函数可以实现运算符的重载，这种方法更适合的是**二元运算**中使用。

```c++
class Clock {
    friend Clock operator-(Clock a, Clock b);
    // 就像友元函数一样要声明这种友元关系
  private:
    int hours;
    int minutes;

  public:
    Clock(int h, int m) {
        hours = h;
        minutes = m;
    }
};
Clock operator-(Clock a, Clock b) {
    a.minutes -= b.minutes;
    if (a.minutes < 0) {
        a.hours = a.hours - 1;
        a.minutes += 60;
    }
    a.hours -= b.hours;
    return a;
}
```

-   注意

需要注意的是友元函数并不是成员函数了，所以不用使用域运算符`::`。
