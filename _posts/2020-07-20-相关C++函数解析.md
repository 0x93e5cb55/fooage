---
layout: post
title: '相关C++函数解析'
date: 2020-07-20 22:29:10 +0800
categories: C++
---

函数在程序中分为有返回值和无返回值。**函数是一种问题的通用方法**，既可以使用标准函数库中的函数也可以自定义需要的函数又分为按值传递、指针传递和引用传递，在`C++`中函数的种类是十分丰富的。

## 使用规则

> 在使用之前提供函数的定义
>
> 提供函数的返回值类型
>
> 调用函数时参数对照
>
> 函数只能有一个返回值其余要用其他形式返回
>
> 实参虚参在内存中的关系复杂

## 基本函数

### 内存的分配

函数在使用时并不是直接使用作为参数的变量，而是用`stack`栈的方法把上一级的变量等数据压入栈而新创建了一份变量供运算使用，所以在使用函数时要考虑到变量的内在关系和生存周期。

### 函数参数

函数在使用过程中将外部的值丢进去计算或者修改这样才使得它有实际作用。

#### 普通参数

其中的 a 和 b 参数是属于函数的，他的生存周期和函数的调用时期是一样的，它只能用于运算而不能改变原来传进去的变量的值，因为在函数里改变的只是变量的副本，一般这种只传递参数的值的传递叫做**按值传递**方法。

```c++
int Add(int a, int b) { return a + b; }
```

#### 引用参数

在 C++中额可以创建一种数据类型为引用类型，引用类型和原变量使用同一个地址的值相当于原变量的一种别名**值**和**地址**都相同。由此可以看出我们可以传递变量的引用来实现修改原变量的目的，比较相近于`C`语言中通过传递**指针**来直接修改指针所指的值的方法。

> 用引用传递变量不仅可以实现以上功能,还省去副本更有效率

```c++
void Add(int a, int b, int &c) {
    c = a + b;
    return;
}
// 代码
int ans = 0;
add(1, 2, ans);
// 调用函数时ans的引用被创建在函数中且被操作，这相当于直接操作ans
```

#### 指针参数

通过指针可以让函数直接通过修改指针指向地址的值来达到修改变量的目的。

```c++
void Add(int a, int b, int *p) {
    *p = a + b;
    return;
}
// 省略代码
int ans = 0;
int *p = &ans Add(1, 2, ans);
// 直接使用指针对变量地址的值直接修改
```

#### 常量参数

```c++
int Change(const int a) { a = a + 1; }
// a所代表的实参即可以是常量，也可以是非常量
```

### 函数与数组

函数在传递数组参数时应该提供数组的名称，和数组的大小以此来实现数组属性的传递。但如果是`STL`中的容器，容器可以将其大小作为自身的固有属性所以说不用再传递它的大小，而是通过一个整体直接传递进来。

-   一维数组

```c++
void Fun(int arr[], int size) {
    for (int i = 0; i < size; i++)
        cout << arr[i] << endl;
}
// []表示该参数为数组
// 省略代码
const arraySize = 10;
int a[arraySize];
Fun(a, arraySize);
// 这也是按值传递的，不能修改原参数数组
```

因为数组的名字本身就是指针而数组在内存中是线性的，所以传递数组头和大小就可以在函数中使用数组。这种传递方法给了函数直接修改原参数的机会，所以不是按值传递。

```c++
void Fun(int *arr, int size) {
    for (int i = 0; i < size; i++)
        arr[i]++;
}
// 等于*(arr+1)++，函数参数并不是按值传递，而是真正的实参
```

通过引用传递数组参数，但这种方法比较局限必须设定大小丧失了函数的通用性。

```c++
void Add(int (&arr)[10]) {
    for (int i = 0; i < 10; i++)
        arr[i]++;
}
// 相当于变量的引用
```

-   多维数组

多维数组传递时一般传递方法比较特殊，必须注明除第二维的大小，这样有些局限通常采用`vector`。

```c++
void Fun(int arr[][5], int size) {
    for (int i = 0; i < size; i++)
        for (int j = 0; j < 5; j++)
            arr[i][j] = 0;
}
// 代码
int number[10][5];
Fun(number, 10);
```

使用指针传递函数参数需要对多维数组在内存中的排列有一定的了解。因为无法像普通二维数组的方式访问数组中的元素，虽然也是随机访问，但角标的表示比较复杂。

```c++
void Fun(int *arr, int h, int l) {
    for (int i = 0; i < h; i++)
        for (int j = 0; j < l; j++)
            cout << arr[i * h + j];
    // 此处的二位数组的表示法比较特殊相等于arr[i][j];
}
```

-   `a[]`和`*x`传递区别

> `a[]`作为参数时传递的是数组头地址常量，不能用`a++`
>
> `*x`是传递地址的指针，指针是可以移动的所以可以使用`x++`

### 容器传递

容器作为参数的传递也会有两种形式的传递，`按值传递`和`实参传递`需要区分。

```c++
// 按值传递
int Max(vector<int> a) {
    // 代码
}
// 这种副本容器的生存周期和函数相同
```

```c++
// 利用引用，引用传递
int Min(vector<int> &a) {
    // 代码
}
// 这种容器本就是实际容器的一种引用所以可以直接修改容器内的元素。
// 虽然函数结束后该引用也被销毁，但原容器已经被修改了
```

通过引用传递容器也是可以的，这样实现直接修改实参。

### 结构传递

函数也同样可以传递结构体，具体方法同样分为两种，和普通变量相同但是会多出一些结构体独有的操作，指针的使用方法也需要`->`来指向元素，还有结构体数组的方法依旧和以上几种方法相同。

```c++
struct Person {
    int age;
    int money;
};
int Fun(struct Person per) {
    per.age = 18;
    per.money *= 10;
}
```

## 内联函数

内联函数是`C++`为提高程序运行速度的一次改进，它和编写普通函数没有差别但是在编译时编译器会对他们做不同的处理。**在编译后的机器码中函数的地址被编写进去并实现函数的调用**，但在内联函数的编译中，函数和其他程序代码在“内部”链接起来了，可以免去函数的调用所带来的代价。

### 使用

```c++
int c = Add(a, b);
// 使用内联函数和普通函数一样，只是编译不同
```

### 声明内联函数

-   关键字 inline

```c++
inline int Add(int a, int b) { return a + b; }
// 加上关键字inline就可以成为内联函数
```

> 内联函数不能递归
>
> 内联函数一般较为简单
>
> 有选择的内联函数
>
> 编译器不能满足所有内联需求即使有`inline`关键字

内联函数无差别的使用，这样其实没有作用，因为编译器无法满足所有的需求，只能自主选择一些适合内联的函数进行操作，所以程序速度的提高不能只依赖内联函数，而是要通过数据结构与算法。

## 重载函数

函数的重载给了函数使用上的更多的可能，函数的重载是在一定基础上利用同名函数的更合适的版本去适应运算。通常是名字相同的函数，有不同的参数列表来定义一个函数的重载函数，这样编译器在参数列表时会判断使用哪一种函数最为合适。

### 使用前提

什么才能算是重载呢？这就要提到参数列表了，参数列表又叫**参数签名**，包括参数的**类型**、参数的**个数**和参数的**顺序**，只要有一个不同就叫做参数列表不同。

```c++
void Swap(int a, int b);
void Swap(double a, double b);
bool Swap(bool a, bool b, bool c);
// 这些函数都重新定义了对应不同参数列表时的函数
```

-   重载规则

1. 函数名称必须相同。
2. 参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。
3. 函数的返回类型可以相同也可以不相同。
4. 仅仅返回类型不同不足以成为函数的重载。

### 内部原理

在`C++`代码在编译的过程中会对函数进行重命名，比如`void Swap(int a,int b)`就会变成`_Swap_int_int`，这样就能知道为什么同名函数如何重载的了。发生函数调用的时候就会按这个表进行匹配，如果匹配不到则会报错。这叫做**重载决议**。

## 模板函数

为了实现**泛型编程**，函数模板是一种通用化的函数的描述，把相应的参数传递给函数之后，编译器会自动生成该类型的函数，但是这种模板的范围也不是无限的，如遇到特殊情况无法重载就会报错。模板函数给程序提供了代码重用的机会和便利。也可以使固定的代码适应多变的条件。

### 注意

> 函数模板无法适用于所有的类型有一定的而范围
>
> 不可以提供产生矛盾的重载
>
> 将同一算法用于不同类型时要用函数模板

### 使用

#### 声明函数模板

为了有通用性，在声明时和定义时必须采取比较有通用性的关键字代替固定的类型。引入关键字`class`或`typename`来代替固定的类型。还要用`template`来说明这是一个模板函数。

-   用`typename`

```c++
template <typename T> void Swap(T &a, T &b) {
    T temp;
    temp = a;
    a = b;
    b = temp;
}
// 为了通用使用，函数中的变量一般使用T类型或者auto类型
```

-   用`class`

```c++
template <class T> void Change(T &a) { a = a + 1; }
```

> 生成的泛型的类型名字不一定是`T`其他的名字只要符合标准也可以
>
> 尽量使用`C++98`标准的`typename`来使用

#### 使用模板函数

模板函数的调用方法和普通函数看起来并无差别但是编译器帮我们实现了函数的`重载`但是重载有限度。

-   编译器隐式的重载

```c++
double a, b;
Swap(a, b);
// 其实在函数调用时被转换成以下的函数
Swap(double &a, double &b) {
    double temp;
    temp = a;
    a = b;
    b = temp;
}
```

-   显式的重载模板

对于不可以通用模板的类型比如数组或者结构体我们可以使用其他手段重载原来的模板函数，使其实现更大程度上的模板化。

```c++
template <typename T> void OutAdd(T a, T b) { cout << a + b; }
template <typename T> void OutAdd(T a[], T b[], int size) {
    for (int i = 0; i < size; i++) {
        cout << a[i] + b[i] << endl;
    }
}
// 在函数模板的参数中并非全都是泛型，根据需要可以时基本类型
```

在重载后的模板函数使用时，编译器会选择参数列表对应的模板并使用，其中具有一些优先级别的不同。

### 区分具体和实例

#### 具体化

当函数遇到更加复杂的不同结构体甚至类时函数的重载无法满足。

```c++
struct Student {
    int grade;
    string name;
} a, b;
template <typename T> void Swap(T &a, T &b) {
    // 代码
}
// 具体化的另一种声明方式
template <> void Swap(Student &x, Student &y);
// 对结构体更细致的要求，只交换特定元素而不是整体如果不具体化将无法使用
template <> void Swap<Student>(Student &x, Student &y) {
    int temp;
    tmp = y.grade;
    y.grade = x.grade;
    x.grade = temp;
}
// 经过显式的具体化后再用模板函数处理Student结构体时就有对应的操作方法了
```

#### 实例化

**需要区分实例化和具体化**，对于声明后的模板函数，存在的只有一种生成函数的模板，但他和实际的函数有区别。最初编译器只能自动的隐式的把函数模板实例化用来运用，如果现实的实例化可以直接命令编译器创建特定的实例，需要用到`<>`来指明实例化的类型。

```c++
template <typename T> void Swap(T &a, T &b) {
    T temp = a;
    a = b;
    b = temp;
}
// 可以声明一份实例比如一下代码
template void Swap<int>(int &a, int &b);
// 代码
// 也可以在使用过程可以显式实例化
double a = 1.0, dobule b = 2.0;
Swap<double>(a, b);
// 既在函数列表前用<>来框选实例化的类型
// 模板中的泛型全部会被该实例代替
```

#### 区分具体化和实例化

|        |          声明方式          | 是否重实现 |
| :----: | :------------------------: | :--------: |
| 具体化 | `template <> 函数名<类型>` |     是     |
| 实例化 |  `template 函数名<类型>`   |     否     |

#### 编译使用优先级

-   编译流程如下

> 创建候选函数列表，包含所有名字相同的函数
>
> 选择可行函数列表，将所有参数个数匹配的函数选出
>
> 查找是否有最佳的可行函数，如果有则使用，如果没有调用出错

-   如果有多个可行函数则遵循一下规则

> 非模板函数优先于模板函数
>
> 显式具体化优于隐式具体化

还有一种特殊的方法可以引导编译器选择模板函数的优先级大于非模板函数。

```c++
Swap<>(a, b);
// 符号<>的使用表示了要使用模板函数，虽然像是实例化，但是并没有实际的类型
```

## 函数指针

和其他数据一样，函数也有它的`地址`。函数的地址存储的时其`机器语言`代码的内存的开始位置，通常用函数指针实现函数作为其他函数的参数。函数指针的作用可以允许他在不用换的时间传递不同的函数的地址，可以在不同的时间使用不同的函数。

### 基本需要

> 函数指针需要函数的地址
>
> 函数的指针需要声明
>
> 函数指针可以通过指针调用所指向的函数

### 指针使用

函数指针的声明和使用基本和普通指针相同，可以类比普通指针。

#### 声明

-   获取地址声明

```c++
double fun(int a, int b) { return a + b; }
double (*p)(int, int);
p = fun;
// 声明时参数应该和要指向的函数的参数列表相同
// (*p)表示p是一个指针而*p和函数等价
```

-   使用指针

```c++
void cal(int x, int y, double (*pf)(int, int)) { cout << x + y + (*pf)(x, y); }
// 以(*pf)代替函数名，即可调用
// 在声明时要准备一个相同类型且参数一样的函数指针形参
```

需要注意函数指针的函数列表同一种指针也会有多种情况比如对待数组时。

```c++
double *f1(const double[], int);
double *f2(const double ar[], int n);
double *f3(const double *, int);
// 三种函数指针可以指向同一种函数
// 函数指针的参数列表和其表达函数的列表的变形规则相同
```

在不想写参数列表时可以直接用`auto`变量直接等于函数地址，函数指针和函数本身同样灵活，同时也有指针的各种性质
