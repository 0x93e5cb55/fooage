---
layout: post
title: '最短路径图论算法'
date: 2020-10-16 14:02:43 +0800
categories: Algorithm
---

最短路径问题是图论中常见的问题，因为求最短路径常常采用的是一种贪心或者动态规划的思想，当然也会有其他的。其代表性的算法有**迪杰斯特拉**算法、**弗洛伊德**算法和**SPFA**算法。它们适用于不同的情况比如普通的有权有向图、有权有环图、还有负权有环图等等。问题很大概率上不是符合模板的题目，但是了解这些算法可以让解决问题的过程中多一种思路和方法。

## 表示图

做图论题怎么能够不知道怎么表示图呢？图中有点、边和权三大要素，表示可以采用邻接矩阵法和邻接表法。

### 邻接矩阵法

邻接矩阵法在离散数学中就已经讲到了，采用一个矩阵让一个维度的角标代表边的起始点，让另一个维度的角标来代表边的终点，最后将矩阵中对应的位记边的长度。

```c++
int graph[10010][10010];
// 提供存储的二维数组
for (int i = 1; i <= m; i++) {
  int u, v, w;
  cin >> u >> v >> w;
  graph[u][v] = w;
}
```

### 邻接表法

邻接矩阵简单直观，但是不管有多少条边都铁定要占掉$n^{2}$的内存空间，这对于较为稀疏的图来说太浪费空间了。如果只记录已经存在的边的数据就能让内存空间大大节省。

```c++
// 边的定义如下所示
struct edge {
  int v; // 边指向的终点
  int w; // 边的权值
};
vector<edge> graph[10010];
// 记录从同一个点开始的所有边
cin >> n >> m;
for (int i = 1; i <= m; i++) {
  int u, v, w;
  cin >> u >> v >> w;
  graph[u].push_back((edge{v, w}));
}
```

## 算法解释

了解了图的表示方法就要开始着手解决最短路径的算法问题了，通用的思路是**不断地尝试路径，用更短的路径更新答案**，知道这个就能够理解下面的算法了。

### 迪杰斯特拉算法

这个`Dijkstra`算法能够运算单源最短路也就是将图上一点为起点时到达所有点的最短路径都算出来，**但不能够处理负权图**。模板题<https://www.luogu.com.cn/problem/P4779>非常典型，采用优先队列优化过的时间复杂度是$O(v \log v)$，已经是很快的一种解决办法了。通常是把图中的图分成两部分，一部分为已经找到最短路径的点的集合`S`和没有确定最短路径的点的集合`U`。每次在`U`中寻找当前路径最短的点加入到`S`中，因为它已经是已知最优解了，即如果从其他点**间接**的到达它时路径已经不是最短了。反复如此操作，当所有点都已经确定则单源最短路查找完毕。

- 贪心

顾名思义就是选择眼前最好的那个而不顾及之后的好坏。这对于人来说不能称得上一种好心态，但是对于问题来说每次选择局部最优解就可能达到全局最优解。

```c++
int dis[10010];
bool vis[10010];
struct edge {
  int num;
  int cost;
  // 运算符重载使得优先队列可以选取路径最短的点优先弹出
  bool operator<(const edge& other) const { return cost > other.cost; }
};
vector<edge> graph[10010];
void Dijkstra(int start) {
  // 将最短路径初始化为无限长
  for (int i = 1; i <= n; i++) {
    dis[i] = INT_MAX;
  }
  // 起始点距离更新并且加入队列
  dis[start] = 0;
  priority_queue<edge> que;
  que.push((edge){start, dis[start]});
  while (!que.empty()) {
    edge t = que.top();
    que.pop();
    if (vis[t.num]) continue; // 跳过已经找到最短路径的点
    vis[t.num] = 1;
    for (int i = 0; i < graph[t.num].size(); i++) {
      edge e = graph[t.num][i];
      // 在图中遍历与该点相连的点是否有更短的路径出现并更新答案
      if (dis[e.num] > dis[t.num] + e.cost) {
        dis[e.num] = dis[t.num] + e.cost;
        // 将更短路径的点加入队列
        que.push((edge){e.num, dis[e.num]});
      }
    }
  }
}
```

到这里可能会对更新最短路径的过程有一些疑惑，<https://www.luogu.com.cn/problem/P1144>这道题将一些操作和更新最短路径操作结合就能够加深印象。

### 弗洛伊德算法

`Floyd`算法是解决任意两点间的最短路径的一种算法，它可以解决图中点之间**有向图**和甚至**没有负权回路的负权图**的最短路径问题，但是时间复杂度是$O(v^{3})$，不适合解决数据量较大的问题。算法中将问题简化为直接到达和间接到达两种情况，遍历所有的点查看是否存在点使得`dis(i,k) + dis(k,j) < dis(i,j)`即从`i`点出发是间接经过`k`点到`j`还是直接到达更优。

```c++
int dis[10010][10010];
// 需要初始化数组以便比较
void Init() {
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
      if (i == j) {
        // 一个点到自己的距离是零
        dis[i][j] = 0;
      } else {
        // 赋一个极大的值
        dis[i][j] = INF;
      }
    }
  }
}
void Floyd() {
  for (int k = 0; k < n; k++) {
    // 每次更新以k为中间点的路径是否比直接路径短
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        // 将最短路径替换成更加短的路径
        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
      }
    }
  }
}
```

因为需要中间点去不断`DP`更新最短路径，所以很多时候有时候可以将取中间点的操作分开。比如这道题<https://www.luogu.com.cn/problem/P1119>中将图中的点一个一个加入就可以利用这些点作为中间点去`DP`更新答案。弗洛伊德算法的思想非常简单但是时间复杂度高，需要结合实际情况使用。

### SPFA 算法

这是一种时间复杂度不太稳定的算法，种种原因会造成它最终的时间复杂度变成$O(ve)$的情况，但是它可以**解决负权图**图（没有负环）的最短路径的问题。通常采用的是`Dijkstra`算法来做最短路径，特殊情况用这种算法来解决。

- 广度优先搜索

这种算是采用了`BFS`的方法去更新最短路径，遍历队首邻接的所有路径，并将原本不在队列中的更短路径点加入队列中。不断找出更短的路径，再从最短路径点进一步松弛最短路径。

```c++
struct edge {
  int num;
  int cost;
};
vector<edge> graph[10010];
int dis[10010];
int vis[10010];
void SPFA(int start) {
  for (int i = 1; i <= n; i++) {
    dis[i] = INT_MAX;
    // 目前队列中没有点在其中
    vis[i] = false;
  }
  dis[start] = 0;
  vis[start] = true;
  // 把起点加入队列
  queue<edge> que;
  que.push((edge){start, dis[start]});
  while (!que.empty()) {
    edge t = que.front();
    que.pop();
    vis[t.num] = false;
    for (int i = 0; i < graph[t.num].size(); i++) {
      edge e = graph[t.num][i];
      // 遍历邻接点并且更新路径长度
      if (dis[t.num] + e.cost < dis[e.num]) {
        dis[e.num] = dis[t.num] + e.cost;
        if (vis[e.num] == false) {
          // 如果没有进入队列的话就让该更短点加入队列
          que.push(e);
          vis[e.num] = true;
        }
      }
    }
  }
}
```

## 最短路径总结

了解了上面几种最短路径的算法之后可以发现它们都用了**三角比较公式**来利用中间点缩短路径，尽管它们的方式各不相同但是核心思想却是相同的。`Dijkstra`算法采用的是优先队列找到最近的点来继续更新路径，而`Floyd`则是直接暴力遍历用动态规划尝试所有中间点来解决，`SPFA`算法采用了广度优先搜索的思想去缩短最短路径。

|   名称   | 适用情况 |    复杂度     |
| :------: | :------: | :-----------: |
| Dijkstra |  正权图  | $O(v \log v)$ |
|  Floyd   | 无负环图 |  $O(v^{3})$   |
|   SPFA   | 无负环图 |    $O(ve)$    |
