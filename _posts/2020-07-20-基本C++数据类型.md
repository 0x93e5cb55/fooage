---
layout: post
title: '基本C++数据类型'
date: 2020-07-20 16:45:23 +0800
categories: C++
---

在计算机中存储数据必须具有以下属性`数据存储位置`、`数据的值`和`存储数据的类型`在编程语言中数据的存在形式是以变量来表示的。在 C++中内置了两种数据类型分为`基本类型`，还可以自定义出类型。

## 命名标准

> 变量名称使用字母字符、数字和下划线
>
> 名称的第一个字符不能是数字
>
> 不能将`C++`关键字作为变量名称
>
> 双下划线和下划线大写字母预留给编译器

通常情况下`C++`程序中**类名和函数名**使用大驼峰法，而**变量名和结构体名**使用小驼峰法，文件名要有实际意义，单词之间用`_`隔开。

## 基础类型

### 前缀

-   无符号型

基本变量类型主要是内置的单体类型，比如字符串、整型和浮点型等。其中还有一种`unsigned`前缀可以去掉符号位，这样就能够让变量的范围在正方向上扩大一倍。

-   静态类型

静态类型`static`在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。比如函数中的静态类型，只会生成一次并且一直独立保持在堆区。

-   跨文件型

如果有需要让一个源码文件中的类型在另一个文件中引用则可以加上`extern`前缀，另一个文件使用时只用声明不用赋值，**函数前也可以加上该前缀**。

### 数型

#### 整型

顾名思义，整型就是整数类型，`C++`没有大数类所以说如果超过`long long`范围的整数就需要另外找方法去计算存储。

|   类型    |                 取值范围                 |
| :-------: | :--------------------------------------: |
|   short   |               -32768~32767               |
|    int    |          -2147483648~2147483647          |
|   long    |        -2147483648 ～ 2147483647         |
| long long | -9223372036854775808~9223372036854775807 |

#### 浮点型

在计算机中相对于定点数而言，浮点数利用指数使小数点的位置可以根据需要而上下浮动，所以就有了**浮点数**来称呼非整数。

|  类型  |        精度         |
| :----: | :-----------------: |
| float  | 7 位十进制有效位数  |
| double | 16 位十进制有效位数 |

浮点数的精度有些特殊，主要分为`float`和`double`两种浮点类型。浮点数的精度是由尾数的位数来决定的。在内存中浮点型的符号位都为`1bit`，而指数位和尾数位不同所以有不同的取值范围，因为按位计算则**需要考虑有效数字的个数而不是真正的大小**。

-   控制输入输出精度

引入对输出格式化的头文件`<iomanip>`使用标准输出对象`cout`来控制精度或者直接使用`printf`。

```c++
// 这样使用通常计数法保留小数点后精度
cout << fixed << setprecision(4) << f << endl;
```

### 字符型

#### 标准字符

| 类型 | 取值范围 |
| :--: | :------: |
| char |  0~127   |

字符型可以和整型进行依照`ASCII`码标准进行转化，在计算时字符也可以代表一定数值，且字符变量有时也可以用整型来初始化。这种灵活的转换让字符类型的使用变得更加灵活并且在底层有更为简洁高效的编码方式。

```c++
char ch = 41;
// 其意义是变量初始化为A字母
```

#### 宽字符

对于非`ASCII`编码的其他语言文字，需要使用有更多编码位的码表进行表示，比如日文和中文。

|  类型   |   支持类型   |
| :-----: | :----------: |
| wchar_t | 其他文字系统 |

-   需要注意的是宽字符需要关键字`L`来标识字符，并用`wcin`和`wcout`的标准输入输出来操作

```c++
// 添加标识符
w_char_t ch = L'好';
wcout << ch << endl;
```

### 布尔型

布尔型的值只有两个`false`假和`true`真。且`false`的序号为`0`，`true`的序号是`1`。还有一个在判断中很重要的部分就是**非零值在在逻辑中都是真**。

### 自由类型

自由类型是在`C++11`标准中引入了`auto`类型，但在平时使用时为了更加的严谨不采用这种类型，它常被运用在函数模板和`STL`库中的一些运用中来实现通用性，它会在声明时自动绑定类型之后不再转换。

```c++
vector<int> number;
auto it = number.begin();
// 这样可以很方便的绑定迭代器
```

## 数组

支持数组数据结构，它可以存储一个固定大小的**相同类型元素的顺序集合**。数组是用来存储一系列数据。它是一种数据结构体而不是绑定与某一个数据类型上的特定结构体，以至于几乎所有的数据类型都能够以数组的形式储存，包括基本数据类型、数组类型、类、结构体类型等。

### 声明

对于数组的声明需要明确一点那就是**数组的大小只能是定值或者常量**，这一点是为了内存安全而存在的。而且数组也是有类型的，其中只能存储对应类型的数据。

#### 声明规范

> 储存在某个数组中数据的类型
>
> 数组的名称同变量名
>
> 数组中的元素个数

### 初始化及使用

其中初始化的位置会影响到数组初始值，全局变量声明的数组元素的值全为`0`相近的值如`false` `\0`

#### 声明赋值法

```c++
int a[4] = {3, 6, 8, 10};
int b[2];
b[0] = 3, b[1] = 4;
// 基础的声明数组的办法
```

#### 不定列表法

```c++
int a[] = {3, 6, 8, 10};
// 自动申请申请空间存储列表中的元素
```

#### 归零法

```c++
float b[100] = {0};
// 编译器去会将其他元素全部赋值为0
```

#### `C++11`标准初始化法

```c++
double b[4]{1.2, 3.7, 1.1, 1.7};
int a[10000]{};
// 将元素全部赋予零值
```

> 数组之间不能直接等号赋值
>
> 数组的下标编译器不会报错但会导致内存溢出
>
> 列表初始化和基本类型一样不允许缩窄
>
> 数组的大小一定是确定的

### 动态申请

对于数组来说大小是固定的，那么如果不知道需要多少内存来存储的时候可能会滥用内存，数组开的过大或者过小。动态内存申请解决了这个问题，在程序的运行过程中，而不是在编译时就决定了内存申请的大小。

#### 动态内存的申请

```c++
int *a = new int[n];
```

因为**动态内存空间是在堆区**则需要指针来指向申请的内存，指向之后就可以正常使用了。

#### 动态内存的释放

对于动态内存，`C++`的内存管理器并不会自动的释放，这在程序运行中十分的危险，这时需要手动释放内存。

```c++
delete[] a;
// 释放指针指向的数组内存
```

### 数组和指针

数组和指针是一对分不开的欢喜冤家，**数组的名字既是数组的变量名也是数组头指针的名字**。

#### 地址关系

在数组中的头指针指向第一个元素，第一个元素的地址就为数组的开始地址。但是也要区分开来数组头和第一个元素的关系，比如`&a`和`&a[0]`的值相等但是意义不相等，前者指向一片内存，后者只指向一个。

#### 使用差别

在使用的过程中不必要太注意这些区别，数组名就可以当作指针来使用就行了，**表达式中的数组都会被自动转换为指向其首元素的指针**。

-   `a[]`和`*x`传递区别

> `a[]`作为参数时传递的是数组头地址常量，不能用`a++`
>
> `*x`是传递地址的指针，指针是可以移动的所以可以使用`x++`

## 结构体

结构体可以自定义类型，同一个结构可以储存多个基本类型甚至嵌套结构体型。结构的声明属于一段完整的代码，所以在结尾需要加上分号表示结束。

```c++
struct Person {
    int age;
    int money;
};
```

### 访问元素

结构体在声明后可以像基本类型一样建立数组和声明，但如果访问其中元素则需特殊方法。

#### 普通访问

```c++
struct Person {
    int age;
    int money;
} stu[10];
stu[1] = {18, 1000};
stu[2].age = 14;
```

#### 指针访问

```c++
struct Person stu[10];
struct Person *p = &stu[0];
p->money = 100;
// 指针p指向了一个结构体，直接用->符号来修改其指向的结构体的元素
```

> 结构体中也可以有外部变量但不提倡，除非是外部全局的常量
>
> 结构体的声明也有作用范围，和基本类型的生存期相同
>
> 相同的结构体之间可以用`=` `>` `<`等运算符，但不是全部

## 共用体

### 使用

共用体的使用跟结构体差不多，声明之后这个共用体类型就可以赋予它的成员值的类型，但是同一时间只能存在一种。

```c++
// 声明共用体
union Price {
    int int_price;
    double double_price;
};
// 使用共用体和结构体非常相像
Price pay;
pay.int_price = 3;
pay.double_price = 3.15;
```

### 与结构体区别

结构体变量所占内存长度是各成员占的内存长度之和，每个成员分别占有其自己的内存单元。**共用体变量所占的内存长度等于最长的成员的长度**。

## 枚举类型

枚举变量的意义是**增加程序的可读性，常用来描述状态量**。枚举常量代表该枚举类型的变量可能取的值，编译系统为每个枚举常量指定一个整数值，默认状态下，这个整数就是所列举元素的序号，序号从`0`开始。并且可以根据需要手动赋值，枚举常量的值可以出现重复。

```c++
enum weekday {
    Sun = 7,
    Mon = 1,
    Tue = 2,
    Wed = 3,
    Thu = 4,
    Fri = 5,
    Sat = 6
}; // 定义枚举类型week
```

这样的枚举常量都可以将枚举常量赋值给枚举变量使用比如如下代码。其中枚举变量`day`**能且只能**被枚举常量赋值。

```c++
// 赋值过程
weekday day = Mon;
```
