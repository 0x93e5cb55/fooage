---
layout: post
title: 'STL标准模板库'
date: 2020-12-20 00:11:27 +0800
categories: C++
---

`C++`通过模板的概念实现了对泛型程序设计的支持，有了`STL`，程序员就不必编写大多数常用的数据结构和算法。而且`STL`是经过精心设计的，运行效率很高，比水平一般的程序员编写的同类代码速度更快。

## 排序

排序是对数组，对象等的有序排列，因为大部分标准函数模板库中的函数只能作用于有序。排序要求对象可交换以及支持`<`运算符来支持排序中的元素交换。

### 普通排序

- **`sort(Begin,End,Comp)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Comp`：排序规则函数返回值为`true`或`false`

```c++
// 可以加入定义好的比较函数来自定义比较
deque<string> word{"nine", "seven", "three", "six", "two"};
sort(word.begin(), word.end(), [](string a, string b) { return a.back() > b.back(); });
```

### 部分排序

- **`partial_sort(Begin,Begin+Range,End,Comp)`**
- `Begin`：初始迭代器/指针和排序结果的开始
- `Begin+Range`：结束迭代器/指针和排序结果的结束
- `End`：排序的范围结尾

```c++
size_t count{5};
vector<int> number{22, 7, 93, 45, 19, 56, 88, 12, 8, 7, 15, 10};
partial_sort(begin(number), begin(number) + count, end(number));
```

### 部分新排序

- **`partial_sort_copy(Begin,End,Target_First,Target_Last,Comp)`**
- `Target`：排序结果的储存目标容器或数组以及范围

```c++
// 把部分排序的排序结果拷贝到另一个容器中
vector<int> number{22, 7, 93, 45, 19, 56, 88, 12, 8, 7, 15, 10};
size_t count{5};
vector<int> result(count);
partial_sort_copy(number.begin(), number.end(), result.begin(), result.end());
// 分别标明排序的开始结束，拷贝的开始和结束
```

### 稳定排序

- **`stable_sort(Begin,End,Comp)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Comp`：排序规则函数返回值为`true`或`false`

```c++
// 进行稳定排序，不交换相等元素
array<double, 5> number = {{1.2, 3.9, 5.0, 5.0, 0.8}};
stable_sort(number.begin(), number.end(), [](double a, double b) { return int(a) > int(b); });
```

### 相对排序

- **`nth_element(Begin,Target,End)`**
- `Begin`：排序目标的查找初始迭代器/指针
- `End`：排序目标的查找结束迭代器/指针
- `Target`：指向目标指针

```c++
// 只把这一个目标元素放置在自己按照排序结果应该在的地方，而其他元素不懂
int number[] = {5, 6, 15, 89, 7, 2, 1, 3, 52, 63, 12, 64, 47};
nth_element(number, number + 6, number + sizeof(number) / sizeof(int));
cout << number[6];
```

### 合并排序

- **`inplace_merge(Begin,Middle,End,Comp)`**
- `Begin`：初始迭代器/指针
- `Middle`：中点迭代器/指针
- `End`：结束迭代器/指针
- `Comp`：比较函数

```c++
vector<int> number = {5, 10, 15, 20, 25, 0, 10, 10, 25, 30};
// 把两部分已经有序的部分合并排序
inplace_merge(number.begin(), number.begin() + 5, number.end());
```

### 合并新排序

- **`merge(Begin_1,End_1,Begin_2,End_2,Target,Comp)`**
- `Begin`：1 或 2 容器的初始迭代器/指针
- `End`：1 或 2 容器的初始迭代器/指针
- `Target`：排序结果目标容器

```c++
vector<int> vec1 = {5, 10, 15, 20, 25};
vector<int> vec2 = {0, 10, 10, 25, 30};
vector<int> result(vec1.size(), vec2.size());
merge(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), begin(result));
```

## 转换

对容器中的元素的转换的函数。

### 元素转换

- **`transform(Begin_1,End_1,Begin_2,Iterator,Fuction)`**
- **`for_each(Begin,End,Iterator,Fuction)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Target`：结果存放容器的初始指针/迭代器
- `Fuction`：应用于元素的函数
- `Iterator`：输出结果的迭代器

```c++
// for_each和transform并无太大区别
vector<int> number_1{1, 3, 5, 7};
vector<int> number_2{2, 4, 6, 8};
vector<int> result;
// 标准函数模板库中的可定制性非常强
transform(begin(number_1), end(number_1), begin(number_2), back_inserter(result), [](int x, int y) { return x * y; });
// 也可以将计算应用在相邻的两个元素上
```

## 查找

对无序或有序容器中元素的查找并返回位置或有无，用搜索函数还可以进行一些更细致的查找。

### 普通搜索

- **`find(Begin,End,Search)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Search`：要查找的值

```c++
list<int> number;
number.push_back(10);
number.push_back(20);
list<int> ：：iterator it = find(number.begin(), number.end(), 10);
// find函数会返回一个迭代器或者指针来指向查找结果
// 如果查找无果则会返回end()
```

### 条件搜索

- **`find_if(Begin,End,Search)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Search`：查找的条件函数或表达式

```c++
int value{5};
int number[] = {10, 5, 25, 10, 35};
// 定义函数来描述查找的对象
auto it =
    find_if(begin(number), end(number), [value](int n) { return n > value; });
```

### 相邻查找

- **`adjacent_find(Begin,End,Search)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Search`：查找的条件函数或表达式

```c++
// 返回指向相邻的第一个元素的迭代器
string str{"Children should be seen and not heard."};
auto it = adjacent_find(begin(str), end(str));
if (it != end(str))
  cout << *it;
// output is 'e'
```

### 相等范围

- **`equal_range(Begin,End,Search)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Search`：查找的条件函数或表达式

```c++
// 只能用于有序的容器中
list<int> coll{1, 2, 2, 4, 5, 7};
pair<list<int>::iterator, list<int>::iterator> range;
// 返回了一对指针来包含相等的区间[)左闭右开
range = equal_range(coll.begin(), coll.end(), 2);
cout << *range.fist << " " << *range.second;
```

### 序列查找

- **`search(Begin_1,End_1,Begin_2,End_2)`**
- **`find_first_of(Begin_1,End_1,Begin_2,End_2)`**
- **`find_end(Begin_1,End_1,Begin_2,End_2)`**
- `Begin`：1 或 2 容器的初始迭代器/指针
- `End`：1 或 2 容器的初始迭代器/指针

```c++
vector<int> v1{5, 8, 1, 4};
vector<int> v2;
v2.push_back(8);
v2.push_back(1);
vector<int> ：：iterator iterLocation;
iterLocation = search(v1.begin(), v1.end(), v2.begin(), v2.end());
// 返回一个指针指向了结果序列的第一个元素位置
```

### 最值查找

- **`max_element(Begin,End)`**
- **`min_element(Begin,End)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针

```c++
array<int> number{1, 3, 2, 9, 5, 2, 4, 0};
int max = *max_element(begin(number), end(number));
int min = *min_element(begin(number), end(number));
```

### 最值范围查找

- **`minmax_element(Begin,End)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针

```c++
array<int> number{1, 3, 2, 9, 5, 2, 4, 0};
pair<array<int>::iterator, array<int>::iterator> range;
// 涉及到范围的函数一般都会返回一对pair对象的结果
rang = minmax_element(number.begin(), number.end());
cout << *range.first;
cout << *range.second;
```

## 满足属性

用于检查元素谓词的是否满足特定谓词，从而返回一个布尔值用于判断。还可以进行比较两个容器。

### 谓词检查

- **`all_of(Begin,End,Comp)`**
- **`any_of(Begin,End,Comp)`**
- **`none_of(Begin,End,Comp)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Comp`：用于检查的`bool`函数

```c++
vector<int> ages{22, 19, 46, 75, 54, 19, 27, 66, 61, 33, 22, 19};
int min_ages = 10;
bool flag = all_of(ages.begin(), ages.end(), [min_ages](int x) { return x > min_ages; });
// 这些函数都是返回bool类型的，满足则会返回1，不满足则会返回0
```

### 比较相等

- **`equal(Begin_1,End_1,Begin_1)`**
- `Begin_1`：容器初始迭代器/指针
- `End_1`：容器结束迭代器/指针
- `Begin_2`：另一容器的初始迭代器/指针

```c++
vector<int> vec1{1, 2, 3, 4, 5, 6};
vector<int> vec2{1, 2, 3, 4, 5, 6};
vector<int> vec3{1, 2, 3, 4, 5, 6, 7};
Vector<int> vec4{2, 3, 4};
bool flag = 0;
// 切记只能用于序列容器，因为要指出开始和结束
flag = equal(vec1.begin(), vec1.end(), vec2.begin());
flag = equal(vec1.begin(), vec1.end(), vec3.begin());
flag = equal(vec1.begin(), vec1.end(), vec4.begin());
// 只要满足定义区间内相等则返回真
```

### 比较指错

- **`equal(Begin_1,End_1,Begin_1,End_2)`**
- `Begin_1`：容器初始迭代器/指针
- `End_1`：容器结束迭代器/指针
- `Begin_2`：另一容器的初始迭代器/指针
- `End_2`：另一容器的结束迭代器/指针

```c++
vector<int> vec1{1, 2, 3, 4, 5, 6};
vector<int> vec2{1, 2, 3, 4, 5, 6};
vector<int> vec3{1, 2, 3, 4, 5, 6, 7};
int flag = 0;
flag = equal(vec1.begin(), vec1.end(), vec2.begin());
flag = equal(vec1.begin(), vec1.end(), vec3.begin());
```

### 字典序比较

- **`lexicographical_compare(Begin_1,End_1,Begin_1,End_2,Comp)`**
- `Begin_1`：容器初始迭代器/指针
- `End_1`：容器结束迭代器/指针
- `Begin_2`：另一容器的初始迭代器/指针
- `End_2`：另一容器的结束迭代器/指针
- `Comp`：自定义比较函数

```c++
// 类似于字符串比较的原理，直接比较字典序
vector<string> phrase1{"the", "tigers", "of", "wrath"};
vector<string> phrase2{"the", "horses", "of", "instruction"};
auto less = lexicographical_compare(begin(phrase1), end(phrase1), begin(phrase2), end(phrase2));
// 前者大返回一，前者小返回零
```

## 位置排列

对容器中的元素顺序进行调换的简单函数。

### 旋转置换

- **`rotate(Begin,New,End)`**
- `Begin`：旋转的初始迭代器/指针
- `End`：旋转的结束迭代器/指针
- `New`：新头元素必须位于`[Begin,End)`

```c++
vector<int> number{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
// 堆区间内的元素进行旋转，知道中间参数的元素处于该区间内第一的位置
rotate(number.begin(), number.begin() + 3, number.end());
rotate(number.begin(), find(begin(number), end(number), 3), number.end());
// 如果用find函数可以找出来新的开头的位置
```

### 随机排列

- **`random_shuffle(Begin,End)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针

```c++
int number[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
random_shuffle(number, number + sizeof(number) / sizeof(int));
// 利用随机数随机排序打乱
```

### 种子随机排列

- **`shuffle(Begin,End,Seed)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Seed`：随机种子生成器

```c++
array<int, 10> number = {{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}};
unsigned seed = chrono：：system_clock：：now().time_since_epoch().count();
shuffle(number.begin(), number.end(), default_random_engine(seed));
// 用系统时间去做种子来随机，这样可以避免假随机
```

### 全排列

- **`next_permutation(Begin,End,Comp)`**
- **`prev_permutation(Begin,End,Comp)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Comp`：排列的方法规则`bool`型函数

```c++
// 默认的排序规则是按字典序的，但同样的可以加上比较参数
vector<string> str{"a", "b", "c"};
do {
  cout << str[0] << " " << str[1] << " " << str[2] << endl;
} while (next_permutation(str.begin(), str.end(), [](string a, string b) { return a < b; }));
```

## 划分分区

对一些容器进行分区把满足某条件的元素调到一起的模板函数，还可以找出分出的区间的界限。

### 生成序列

- **`partition(Begin,End,Judgment)`**
- `Begin`：初始迭代器/指针用于表区间
- `End`：结束迭代器/指针用于表区间
- `Judgment`：判断函数返回 1 则满足返回 0 则不满足

```c++
vector<int> number{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int point = partition(number.begin(), number.end(), [](int a) { return (a % 2) == 0 });
// 让满足条件的元素置于前，不满足的置于后
```

### 查找分界点

- **`partition_point(Begin,End,Judgment)`**
- `Begin`：查找区间初始迭代器/指针
- `End`：查找区间结束迭代器/指针
- `Judgment`：分区的满足条件，返回分区位置的指针/迭代器

```c++
vector<int> number{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int point = partition_point(number.begin(), number.end(), [](int a) { return (a % 2) == 0; });
```

### 稳定生成序列

- **`stable_partition(Begin,End,Judgment)`**
- `Begin`：查找区间初始迭代器/指针
- `End`：查找区间结束迭代器/指针
- `Judgment`：分区的满足条件，返回分区位置的指针/迭代器

```c++
vector<int> number{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
// 类似于稳定排序，不改变相对位置
int point = stable_partition(number.begin(), number.end(), [](int a) { return (a % 2) == 0; });
```

### 稳定新序列

- **`partition_copy(Begin,End,Adder1,Adder2,Judgment)`**
- `Adder`：运用`back_inserter()`向容器中分类添加

```c++
bool cmp(double x, double y) { return x <= y; }
vector<double> number{65, 75, 56, 48, 31, 28, 32, 29, 40, 41, 44, 50};
vector<double> small;
vector<double> big;
// 需要有两个容器来承接分区后前后区域的结果
double aver = accumulate(number.begin(), number.end(), 0.0) / number.size();
partition_copy(number.begin(), number.end(), back_inserter(small), back_inserter(big), cmp);
// 用比较函数cmp返回1的会进入第一个容器，反之进入第二个
```

## 算数

基本函数模板库中对数学运算的函数，以及一些和数相关的函数。

### 值统计

- **`count(Begin,End,Search)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Search`：统计元素的值

```c++
int number[10] = {0, 1, 9, 3, 1, 5, 6, 2, 8, 1};
int result = count(number, number + 10, 1);
// 统计某一个值在区间内出现的次数
```

### 谓词统计

- **`count_if(Begin,End,Search)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Search`：判断条件的`bool`型函数作为统计条件

```c++
vector<int> number{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
count_if(begin(number), end(number), [](int x) { return x > 5; });
// 统计满足某一条件在区间内出现的次数
```

### 求和

- **`accumulate(Begin,End,Value,Rule)`**
- `Begin`：计算的初始迭代器/指针
- `End`：计算的结束迭代器/指针
- `Value`：计算的初始值
- `Rule`：自定义运算的自定义函数

```c++
// 还可以定制运算，默认是加法
int number[] = {100, 20, 33, 25, 77};
accumulate(number, number + 5, 1, [](int a, int b) { return a * b; });
```

### 部分输出和

- **`partial_sum(Begin,End,Iterator,Rule)`**
- `Begin`：计算的初始迭代器/指针
- `End`：计算的结束迭代器/指针
- `Iterator`：输出逐步结果的迭代器
- `Rule`：自定义运算的自定义函数

```c++
vector<int> data{2, 3, 5, 7};
vector<int> result;
partial_sum(begin(data), end(data), back_inserter(result), [](int x, int y) { return x * y; });
// back_inserter用来把每次计算的结果插入到另一个容器
// 可以定义运算规则，默认是加法
```

### 矩阵内积

- **`inner_product(Begin_1,End_1,Begin_2,Value)`**
- `Begin_1`：积数的初始迭代器/指针
- `End_1`：积术的结束迭代器/指针
- `Begin_2`：另一积数的初始迭代器/指针
- `Value`：计算的初始值

```c++
vector<int> first(10);
vector<int> second(10);
iota(begin(first), end(first), 2);
iota(begin(Second), end(Second), 3);
// iota函数默认升序填充容器
int result = inner_product(first.begin(), first.end(), second.begin(), 0);
```

### 相邻元素差

- **`adjacent_difference(Begin,End,Iterator,Comp)`**
- `Begin`：比较的初始迭代器/指针
- `End`：比较的结束迭代器/指针
- `Iterator`：结果的输出迭代器
- `Comp`：比较求差的比较函数

```c++
// 加入操作函数
int fun(int x, int y) { return x + y; }
int number[] = {2, 3, 5, 7};
vector<int> result;
adjacent_difference(number, number + 4, back_inserter(result), fun);
// 2 5 8 12
// 计算相邻元素的和，注意开始的地方
```

### 取样

- **`sample(Begin,End)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针

```c++
array<int, 10> number = {{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}};
auto result = sample(number.begin(), number.end());
// 随便返回容器中的某一个元素
```

## 操作

对容器的一些基本操作函数。

### 复制

- **`copy(Begin_1,End_1,Begin_2)`**
- **`move(Begin_1,End_1,Begin_2)`**
- `Begin`：1 或 2 容器的初始迭代器/指针
- `End`：1 或 2 容器的初始迭代器/指针

```c++
// 需要准备好相应大小的容器来容纳拷贝
vector<int> number{1, 2, 3, 4};
copy(number.begin(), number.end(), number.begin() + 1);
```

### 序列交换

- **`swap_ranges(Begin_1,End_1,Begin_2)`**
- `Begin`：1 或 2 容器的初始迭代器/指针
- `End`：1 或 2 容器的初始迭代器/指针

```c++
set<string, greater(string) <>> word_1{"one", "two", "three"};
set<string, greater(string) <>> word_2{"four", "five", "six"};
swap_ranges(word_1.begin(), word_1.begin() + 2, word_2.begin() + 1);
// 把两个容器两个区间或者一个容器内两个区间的元素交换
```

### 填充

- **`fill(Begin,End,Value)`**
- **`fill_n(Begin,Num,Value)`**
- `Begin`：1 或 2 容器的初始迭代器/指针
- `End`：1 或 2 容器的初始迭代器/指针
- `Value`：需要填充的满足容器类型的值
- `Num`：值的赋予次数

```c++
double number[4];
fill(number, number + 4, 0);
```

### 递增赋值

- **`iota(Begin,End,Value)`**
- `Begin`：1 或 2 容器的初始迭代器/指针
- `End`：1 或 2 容器的初始迭代器/指针
- `Value`：需要递增的满足容器类型的初始值

```c++
double number[4];
iota(number, number + 4, 0);
// 0 1 2 3
```

### 函数遍历

- **`generate(Begin,End,Fuction)`**
- **`generate_n(Begin,Num,Fuction)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Fuction`：自定义函数
- `Num`：函数应用的操作次数

```c++
vector<string> str{"a", "b", "c", "d"};
generate(str.begin(), str.end(), [](string x) { return "a" + x; });
// 类似于transform，相当于把某一函数分别套用在区间内所有元素上
```

### 特殊替换

- **`replace(Begin,End,Value,New)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Value`：要检索的值
- `New`：替换的新值

```c++
deque<int> number{1, 2, 2, 3, 4};
replace(begin(number), end(number), 2, 4); // 1 4 4 3 4
```

### 条件替换

- **`replace_if(Begin,End,Comp,New)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Comp`：比较函数用于查找符合替换条件的元素的`bool`函数
- `New`：替换的新值

```c++
deque<int> data{10, -5, 12, -6, 10, 8, -7, 10，11};
vector<int> data_copy;
replace_if(begin(data), end(data), back_inserter(data_copy), [](int value) { return value < 0; }, 99);
// 把满足某一条件的元素替换
```

### 移出数据

- **`remove(Begin,End,Value)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Yalue`：需要移除的值

```c++
list<int> number{1, 4, 4, 7};
remove(number.begin(), number.end(), 4);
// 把元素移出到不可见位置，但没有删除内存空间
```

### 擦除数据

- **`erase(Begin,End)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针

```c++
int number[]{1, 4, 4, 7, 8};
erase(number, number + 3);
// 删除元素，并删除内存空间
```

### 去重操作

- **`unique(Begin,End,Comp)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Comp`：特殊函数用于重载默认`==`运算符

```c++
struct stc {
    int a;
    double b;
} snake[3];
// 特化后可以用于结构体
unique(snake, snake + 3, [](struct stc x, struct stc y) { return (x.a == y.a) && (x.b == y.b); });
```

## 集合运算

标准模板库中的集合用`set`储存，对其中元素取并集取交集等集合操作的函数。其中`set`中的元素满足数学意义上的集合关系，元素唯一但不一定有序。如果要插入相同的元素应该用其他或者用`multiset`。

### 集合差运算

- **`set_difference(Begin_1,End_1,Begin_2,End_2,Iterator)`**
- `Begin`：1 或 2 容器的初始迭代器/指针
- `End`：1 或 2 容器的初始迭代器/指针
- `Iterator`：结果的输出迭代器

```c++
set<string, greater<string>> word_1{"one",  "two",  "three", "four", "five", "six"};
set<string, greater<string>> word_2{"four",  "five",  "six", "seven", "eight", "nine"};
set<string, greater<string>> result;
// 前面参数的区间减去后面参数的区间
set_difference(begin(word_1), end(word_1), begin(word_2), end(word_2), inserter(result, begin(result)), greater<string>());
// 用back_inserter输出结果
```

### 集合相对差运算

- **`set_symmetric_difference(Begin_1,End_1,Begin_2,End_2,Iterator)`**
- `Begin`：1 或 2 容器的初始迭代器/指针
- `End`：1 或 2 容器的初始迭代器/指针
- `Iterator`：结果的输出迭代器

```c++
// 相对差就是，两者之间所有特有元素
set<int, <int> greater> number_1{1, 4, 5, 6};
set<int, <int> greater> number_2{1, 3, 5, 8};
set_symmetric_difference(number_1.begin(), number_1.end(), number_2.begin(), number_2.end(), ostream_iterator<int>{cout, " "}); // 3 4 6 8
```

### 集合交运算

- **`set_intersection(Begin_1,End_1,Begin_2,End_2,Iterator)`**
- `Begin`：1 或 2 容器的初始迭代器/指针
- `End`：1 或 2 容器的初始迭代器/指针
- `Iterator`：结果的输出迭代器

```c++
set<int, <int> greater> number_1{1, 4, 5, 6};
set<int> number_2;
set<int> result;
number_2.inserter(2);
number_2.inserter(5);
set_intersection(number_1.begin(), number_1.end(), number_2.begin(), number_2.end(), inserter(result, begin(result)));
```

### 集合并运算

- **`set_union(Begin_1,End_1,Begin_2,End_2,Iterator)`**
- `Begin`：1 或 2 容器的初始迭代器/指针
- `End`：1 或 2 容器的初始迭代器/指针
- `Iterator`：结果的输出迭代器

```c++
set<int, <int> greater> number_1{1, 4, 5, 6};
set<int, <int> greater> number_2{2, 3, 5, 8};
set_union(number_1.begin(), number_1.end(), number_2.begin(), number_2.end(), ostream_iterator<int>{cout, " "});
```

### 包含关系判断

- **`includes(Begin_1,End_1,Begin_2,End_2)`**
- `Begin`：1 或 2 容器的初始迭代器/指针
- `End`：1 或 2 容器的初始迭代器/指针
- `Iterator`：结果的输出迭代器

```c++
vector<string> word_1{"one", "three", "five"};
vector<string> word_2{"three", "two", "one", "seven", "nine", "five"};
bool flag = includes(begin(word_1), end(word_2), begin(word_2), end(word_2)); // flag == true
// 是一种返回bool类型的函数，满足则一，反之则零
```

## 堆操作

堆是一种特殊的数据组织方式，其中父节点总是大于或等于子节点的堆称作大顶堆，父节点总是小于或等于子节点的称作小顶堆。注意，给定父节点的子节点不一定按顺序排列。

### 建立堆

- **`make_heap(Begin,End,Comp)`**
- `Begin`:初始迭代器/指针
- `End`:结束迭代器/指针
- `Comp`:大顶堆函数`less<>()`，小顶堆函数`greater<>()`

```c++
vector<int> number;
make_heap(number.begin(), number.end(), less<int>());
```

### 向堆中添加元素

- **`push_heap(Begin,End,Comp)`**
- `Begin`:初始迭代器/指针
- `End`:结束迭代器/指针
- `Comp`:大顶堆函数`less<>()`，小顶堆函数`greater<>()`

```c++
vector<int> number{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
make_heap(number.begin(), number.end(), less<int>()) number.push_back(10); // 只是将元素推入了容器中
push_heap(number.begin(), number.end());
// 容器刷新后，要重新推一遍堆
```

### 从堆中删除元素

- **`pop_heap(Begin,End,Comp)`**
- `Begin`:初始迭代器/指针
- `End`:结束迭代器/指针
- `Comp`:大顶堆函数`less<>()`，小顶堆函数`greater<>()`

```c++
vector<int> number{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
make_heap(number.begin(), number.end(), less<int>());
pop_heap(number.begin(), number.end());
// 弹出堆顶元素到容器最后面，切记这不是完全删除
number.pop_back();
// 弹出堆顶的元素到容器的最后面之要把它从容器中弹出才可以完全出堆
```

### 堆排序

- **`sort_heap(Begin,End,Comp)`**
- `Begin`：初始迭代器/指针
- `End`：结束迭代器/指针
- `Comp`：大顶堆函数`less<>()`，小顶堆函数`greater<>()`

```c++
vector<int> number{0, 2, 3, 1, 5, 9, 4, 6, 7, 8};
make_heap(number.begin(), number.end(), greater<int>());
// 建立一个小顶堆
sort_heap(number.begin(), number.end(), greater<int>());
// 利用堆数据结构总是将最大最小元素放在堆顶的特点不断弹出排序
```
