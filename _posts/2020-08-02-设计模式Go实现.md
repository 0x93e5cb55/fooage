---
layout: post
title: '设计模式Go实现'
date: 2020-08-02 16:20:23 +0800
categories: Golang
---

**设计模式代表了最佳的实践**，通常被有经验的面向对象的软件开发人员所采用。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。站在巨人的肩膀上才能看得更远，但对于小程序的编写其实不是太必要强行套用各种设计模式，该怎么办怎么办就好。

## 创建型模式

这种设计模式主要是对对象创建逻辑的封装，而不是直接在代码中显式的采用构造函数或者`new`类型关键字去创建对象。这样提高了程序在对于某个需要的时候创建对象的可扩展性有提高。

### 单例模式

- 适用场景

1. 需要频繁访问的数据库或者文件对象，连接或者重新读取很麻烦
2. 该对象保有当前的状态信息，不能够被重置
3. 创建对象的时候要消耗大量的资源并且频繁使用

```go
type Config struct {
	Name  string
	Email string
}
// 设置一个全局变量使用
var cfg *Config
func NewConfig(name string, email string) *Config {
	// 检查对象是否存在
	if cfg == nil {
		// 使用once包中的保证只生成一次
		once.Do(func() {
			cfg = &Config{
				Name:  name,
				Email: email,
			}
			return cfg
		})
	}
	return cfg
}
// 因为只生成一次，所以是并发安全的
```

### 工厂模式

通过定义一个接口，用不同的子类来实现这个接口，在创建的过程中不会暴露创建逻辑，可以很方便的**在不同的情况下创建不同的对象实现接口**来使用。

#### 简单工厂

简单工厂的实现非常简单就是通过`switch`来根据不同的参数来返回不同的对象而已。

```go
// 接口用于适配输出对象
type Student interface {
	Say()
}
type GoodStudent struct{}
func (g *GoodStudent) Say() {
	fmt.Println("Hello!")
}
type BadStudent structs{}
func (b *BadStudent) Say() {
	fmt.Println("Fuck!")
}
// 工厂函数用于生成实现该种类接口的不同对象
func Create(method string) Student {
	switch isGood {
	case "good":
		return &GoodStudent{}
	case "bad":
		return &BadStudent{}
	}
}
```

**弊端**：增加一个新的类型时，除了要增加新的类和方法之外，还需要修改工厂函数，在工厂函数中添加 case，这一点违背了开放-封闭原则。

#### 工厂方法

工厂方法和上面的简单工厂的区别是，工厂方法进一步对工厂提供了接口，**可以给对应的产品设置对应的工厂**。

```go
// 不同之处在于工厂的设置
type Factory interface {
	CreateProduct()
}
type FactoryA struct{}
type FactoryB struct{}
// 省略对应的产品和方法
```

#### 抽象工厂

抽象工厂针对的是多个对象等级，有不同种类的对象可以由抽象工厂来生成实现。

```go
// 工厂和产品的接口
type School interface {
	// 注意这里的返回值是产品的接口
	CreateGoodStudent() Student
	CreateBadStudent() Student
}
type Student interface {
	Say()
}
type GoodStudent struct{}
func (g *GoodStudent) Say() {
	fmt.Println("Hello!")
}
type BadStudent struct{}
func (b *BadStudent) Say() {
	fmt.Println("Fuck!")
}
// 通过对方法的层层调用形成了不同的种类的区分
type SchoolA struct{}
func (s *SchoolA) CreateGoodStudent() Student {
	return &GoodStudent{}
}
func (s *SchoolA) CreateBadStudent() Student {
	return &BadStudent{}
}
// 这里省略SchoolB因为工厂基本相同，都是生产产品的函数
```

## 结构型模式

结构型设计模式主要是用于管理类之间的组合和继承，并且结合接口来实现新的生成对象的功能的管理。

### 装饰器模式

动态的包装一个对象，增加这个对象的功能，这样做的使用**组合代替继承**的方法。用装饰的方法在运行时添加或者删除职责比静态的书写继承更加的简便而且易用。

```go
// 装饰器来包装原来的功能让其本身不发生改变而添加新的功能
type Car interface {
	Move()
}
// 被装饰的对象
type NormalCar struct{}
func (n *NormalCar) Move() {
	fmt.Println("Moving...")
}
type FastCar struct {
	// 装饰器有一个被装饰的对象
	normalCar NormalCar
}
func (f *FastCar) Move() {
	normalCar.Move()
	// 装饰的内容就如同是语句中的形容词或者状语，更加丰富了功能
	fmt.Println("Fast!")
}
```

### 代理模式

代理模式是让一个对象对被代理对象提供代理，就是通过这个代理对象来跟本来的对象进行一些交互而不是直接通过和被代理对象交互，这样又提供了一层访问控制。

> 网络连接的访问
>
> 较大资源文件的访问

```go
// 所代理的函数操作
type ProxyFunc interface {
	Say()
}
// 被代理对象
type Person struct {
	Name string
}
func (p *Person) Say() {
	fmt.Println("Hello!")
}
// 代理者是通过有名的内嵌被代理对象的指针来实现代理
type Proxier struct {
	person *Person
}
func (p *Proxier) Say() {
	if p.person == nil {
		// 建立代理关系
		p.person = &Person{}
	}
	// 通过这个代理来调用被代理者的方法
	p.person.Say()
}
```

通常使用的过程中是通过之**直接的主动赋值**而不是等待代理者执行函数的时候才绑定的被代理者。

```go
person := &Person{
	Name: "Wong",
}
proxier := &Proxier{
	// 直接绑定之后代理者就是被代理者的经纪人了，帮忙代替它处理业务
	person: person,
}
```

### 适配器模式

将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。——`Gang of Four`，这就是适配器的含义的描述了。

1. 适配器包含老接口，通常要实现老接口的实例来赋值
2. 用适配器调用老接口的函数包装
3. 将老接口函数转化为新接口的函数名

```go
type Old interface {
	// 需要进行转换的方法
	Talk()
}
type New interface {
	Say()
}
type Adapter struct {
	// 适配器中包含了老接口才能进行转换
	old Old
}
// 在实现新接口方法中调用老接口的方法
func (a *Adapter) Say() {
	a.old.Talk()
}
```

## 行为型模式

行为型模式主要面向的是对象之间的通信和协同关系，通常一个任务需要多个对象的多个方法来完成实现的，这时候就需要通过行为模式来对其进行规划。

### 策略模式

定义一系列算法**实现同一个接口**，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，这种变化符合**开闭原则**，可以不修改主要程序的情况下添加功能。

首先通过策略接口去定义一系列的算法，**给执行者的策略接口赋值**来让执行者同样的调用调用不同的算法，但由于是通过接口实现的所以一个算法一个类，类的数量就会很多。

```go
// 设置这一系列算法的共同接口
type Strategy interface {
	Do(float64, float64) float64
}
// 加法对象
type Add struct{}
func (a *Add) Do(x, y float64) float64 {
	return x + y
}
type Sub struct{}
func (s *Sub) Do(a, b float64) float64 {
	return a - b
}
// 最后由一个包含该接口方法的对象来作为主程序中出现的通用操作者来操作
type Operator struct {
	// 有名组合了一个接口
	strategy Strategy
}
// 给这个通用操作者附上操作
func (o *Operator) SetStrategy(strategy Strategy) {
	o.strategy = strategy
}
func (o *Operator) Calculate(a, b float64) float64 {
	// 可以调用这个目前这个接口的值来进行不同的操作
	return o.strategy.Do(a, b)
}
```

> 有一个技巧那就是如果结构体嵌套了匿名接口，则该结构体初始化的时候可以使用实现了该接口的对象去初始化，即使对应的属性不一样

### 观察者模式

当观察者对象所依赖的或者同步的被观察者发生改变的时候进行**通知**，同步做出改变。

- 被观察者通知观察者进行改变是核心

```go
type Database interface {
	Update()
}
// 两个观察者数据库
type A struct{}
func (a *A) Update() {
	fmt.Println("Data A Update...")
}
type B struct{}
func (b *B) Update() {
	fmt.Println("Data B Update...")
}
// 被观察者用户旗下对应多个数据库
type User struct {
	Databases []Database
}
func (u *User) Notify() {
	for _, db := range u.Databases {
		// 当被观察者发生改变的时候通知数据库更改信息
		db.Update()
	}
}
```

### 命令模式

命令模式可以将发送者和接收者**完全解耦**，使他们之间没有直接的引用关系。发送者只需要知道如何发送请求，接收者只需要知道如何完成请求。

主要分为以下四个角色：

> `Receiver`：接收者做出请求相应的操作
>
> `Invoker`：通过命令对象来发送请求
>
> `Command`：抽象的接口包含执行请求的`Execute()`这个方法调用了接收者的操作
>
> `ConcreteCommand`：具体的命令对象实现了`Command`接口

```go
// 接收者
type Car struct{}
// 接收者对接命令的操作
func (c *Car) Start() {
	fmt.Println("Start to moving")
}
// 定义了命令的接口
type Command interface {
	Execute()
}
// 命令对象
type StartCommand struct {
	// 命令的对象需要包含接收者来调用接收者的操作
	car Car
}
func (s *StartCommand) Execute() {
	// 无需知道命令著需要执行命令就能达到相应的操作
	s.car.Start()
}
```

### 模板方法模式

模板方法模式定义了一个算法的步骤，并允许子类别为一个或多个步骤提供其实践方式。让子类别在不改变算法架构的情况下，重新定义算法中的某些步骤。`Golang`中子类如果不重写父类的方法则会直接使用父类的方法，模板方法模式其实就是抽象类的子类的重写。

```go
type Work interface {
	InitTask()
	StartWork()
	EndWork()
	Work()
}
type Worker struct{}
// 分别重写几个方法，最后执行的时候还是按照顺序但是具体方法已经被重写了
func (w *Worker) InitTask() {
	fmt.Println("Init...")
}
func (w *Worker) StartWork() {
	fmt.Println("Start...")
}
func (w *Worker) EndWork() {
	fmt.Println("End...")
}
func (w *Worker) Work() {
	w.InitTask()
	w.StartWork()
	w.EndWork()
	// 这个函数时关键，包含了该操作的流程，常由父类去定义这个方法，用子类重写其中步骤
}
```
