---
layout: post
title: 'Go测试代码'
date: 2020-08-02 04:34:56 +0800
categories: Golang
---

`Go`自带了测试框架和工具，在`testing`包中，以便完成单元测试`Test`和性能测试`Benchmark`。一般测试代码放在后缀`_test`文件中，与被测代码放于同一个包中，在编译的过程中不会把这些文件编译进可执行文件中，而使用指令可以区测试这些代码查看是否能够得到正确结果，就像评测机一样还能测试性能。

## 命令测试指令

在命令行中使用如下命令就可以自动开始测试包内的测试用例。

### 测试指令

```bash
# 简单测试通过与否
go test
# 输出测试详细信息和标准输入输入
go test -v
```

### 测试参数

有些有用的参数可以客制化测试的过程，比如显示测试覆盖率和指定某些测试的函数而不是运行并测试全部的。

#### 运行对象指定

- 全部对象

这里就像文件的选定一样，用`.`来代表当前目录所有的测试文件。

```bash
go test -v -run=.
```

- 选择测试方式

通常有单元测试和基准测试两种，使用参数也可以选择这些测试方法全部进行还是只进行一种。

```bash
# 选择单元测试
go test -v -run=. -brench=^$
# 选择基准测试
go test -v -brench=. -test=^$
```

- 选择一类测试用例

```bash
go test -v -run="Add|Sub"
# 只要测试函数名包含这两个字段就会测试，反之不进行测试
```

#### 测试覆盖率

一个好的稳定的`Go`项目离不开好的测试检测，有时候对项目的测试覆盖率有很高的要求。

- 本次覆盖率

```bash
go test -cover
```

- 生成覆盖率日志

```bash
go test -v -coverprofile=cover.out
```

## 单元测试

单元测试可以对单个函数进行测试，测试的函数命名要以`Test`开头之后加上非小写开头的函数原名。

> 规定必须加上一个`*testing.T`的参数才能测试

```go
func TestAdd(t *testing.T) {
	type args struct {
		a int
		b int
	}
	tests := []struct {
		// 测试名字
		name string
		// 测试参数结构体
		args args
		// 测试的目标结果
		want int
	}{
		// 在这里添加测试用例结构体
		{
			name: "case",
			args: args{
				a: 1,
				b: 4,
			},
			want: 5,
		},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			// 单元测试独有的测试函数来测试格式如上
			if got := Add(test.args.a, test.args.b); got != test.want {
				// 如果不符合预期则出现失败提示
				t.Errorf("Add() = %v, want %v", got, test.want)
			}
		})
	}
}
```

## 基准测试

如果要进行基准测试来测试代码性能可以使用`Benchmark`前缀加上函数名来进行基准测试，可以增添对各种因素的监控和测试结果数据，比如`CPU`和内存的效率数据问题。

> 必须加上`*testing.B`参数才能够被视作是完全的基准测试

### 书写方法

```go
func BenchmarkAdd(b *testing.B) {
	// 其中的测试次数是系统预制好的
	for i := 0; i < b.N; i++ {
		// 这里只需要把需要测试的代码放进去就行了
		Add(3, 1)
	}
}
```

如果测试的时候需要加载一些资源但是这些资源又不需要加入进测试当中可以使时间重置从测试处开始计时。

```go
func BenchmarkAdd(b *testing.B) {
	// 测试前加载的部分
	Loading()
	// 重置计时
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		Add(2, 4)
	}
}
```

### 测试参数

有很多独有的测试参数可以被使用用于获得更加详细的测试数据，还可以多次进行性能测试来保证测试结果的有效性。

#### 指定逻辑核心数

现在很多机器都有了多核心处理器，那么它的逻辑核心就是最大物理线程数。`-cpu`可以进行指定测试时使用的逻辑核心数来测试不同环境下的运行情况。

```bash
# 指定了测试时的逻辑核心数量会生成多组结果
go test -bench=. -cpu=1,2,4
```

#### 测试次数

对于测试的次数越多越好，因为测试过程会受到种种外部因素的影响而且实际使用的过程中也会有不同的外部环境。

```bash
# 设定测试次数
go test -bench=. -count=10
```
